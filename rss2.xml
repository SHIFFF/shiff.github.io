<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>微弱的光</title>
    <link>http://shiff.top/</link>
    
    <atom:link href="http://shiff.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>千里之行，始于足下</description>
    <pubDate>Fri, 17 May 2024 17:30:42 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>vue文档学习</title>
      <link>http://shiff.top/2024/05/18/vue%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0/</link>
      <guid>http://shiff.top/2024/05/18/vue%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Fri, 17 May 2024 16:11:20 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Vue-js&quot;&gt;&lt;a href=&quot;#Vue-js&quot; class=&quot;headerlink&quot; title=&quot;Vue.js&quot;&gt;&lt;/a&gt;Vue.js&lt;/h1&gt;&lt;p&gt;vue官方文档 &lt;a href=&quot;https://cn.vuejs.org/guide/introducti</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h1><p>vue官方文档 <a href="https://cn.vuejs.org/guide/introduction.html">https://cn.vuejs.org/guide/introduction.html</a></p><p>基于vue方法文档的学习笔记，初学时主要记录基础知识，深度学习后希望能加上自己的理解！</p><h3 id="更新时间"><a href="#更新时间" class="headerlink" title="更新时间"></a>更新时间</h3><p>2024.05.18第一次更新</p><h2 id="什么是Vue"><a href="#什么是Vue" class="headerlink" title="什么是Vue"></a>什么是Vue</h2><p>一款用于构建用户界面的 （JavaScript ）渐进式框架框架</p><p>两个功能：</p><ul><li><strong>声明式渲染</strong>：vue的模板语法使得我们可以声明式地描述HTML和JS状态之间的关系</li><li><strong>响应性</strong>：自动跟踪JS状态并响应式地更新DOM</li></ul><h2 id="Vue可以使用的场景"><a href="#Vue可以使用的场景" class="headerlink" title="Vue可以使用的场景"></a>Vue可以使用的场景</h2><ul><li>无需构建步骤，渐进式增强静态的 HTML</li><li>在任何页面中作为 Web Components 嵌入</li><li>单页应用 (SPA)</li><li>全栈 &#x2F; 服务端渲染 (SSR)</li><li>Jamstack &#x2F; 静态站点生成 (SSG)</li><li>开发桌面端、移动端、WebGL，甚至是命令行终端中的界面</li></ul><h2 id="单文件组件（SFC——-vue"><a href="#单文件组件（SFC——-vue" class="headerlink" title="单文件组件（SFC——*.vue)"></a>单文件组件（SFC——*.vue)</h2><p>vue的标志性功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="Vue组件的书写风格"><a href="#Vue组件的书写风格" class="headerlink" title="Vue组件的书写风格"></a>Vue组件的书写风格</h2><h3 id="选项式API-（Option-API）"><a href="#选项式API-（Option-API）" class="headerlink" title="选项式API （Option API）"></a>选项式API （Option API）</h3><ul><li>用对象来描述组件逻辑</li><li>对象包括data、methos、mouted等属性，这些属性都是可选式的（我自己的理解，不一定对）</li><li>选项定义的属性会暴露在函数内部的this上（即可以通过this访问到这个属性），this指向当前组件的实例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  // data() 返回的属性将会成为响应式的状态</span><br><span class="line">  // 并且暴露在 `this` 上</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // methods 是一些用来更改状态与触发更新的函数</span><br><span class="line">  // 它们可以在模板中作为事件处理器绑定</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      this.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 生命周期钩子会在组件生命周期的各个不同阶段被调用</span><br><span class="line">  // 例如这个函数就会在组件挂载完成后被调用</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(`The initial count is $&#123;this.count&#125;.`)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="组合式API（Composition-API）"><a href="#组合式API（Composition-API）" class="headerlink" title="组合式API（Composition API）"></a>组合式API（Composition API）</h3><ul><li>可以使用导入的API函数描述组件逻辑</li><li>组合式API与<code>&lt;script setup&gt;</code>搭配使用，其中<code>setup</code>是一个标识，使得我们可以更简洁地使用组合式API（会在编译时做一些处理）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, onMounted &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">// 响应式状态</span><br><span class="line">const count = ref(0)</span><br><span class="line"></span><br><span class="line">// 用来修改状态、触发更新的函数</span><br><span class="line">function increment() &#123;</span><br><span class="line">  count.value++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 生命周期钩子</span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">  console.log(`The initial count is $&#123;count.value&#125;.`)</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="两者之间的异同"><a href="#两者之间的异同" class="headerlink" title="两者之间的异同"></a>两者之间的异同</h3><ul><li>选项式API基于组件式API</li><li>选项式有面对对象的思想，对初学者更友好，强制按照选项来组织代码</li><li>组件式的核心思想是直接在函数作用域内定义响应式状态变量，并从多个函数中得到的状态组合起来处理复杂问题。更自由、灵活，但更难理解（确实，我不太能理解）</li></ul><h2 id="互动教程（组件式API-SFC）"><a href="#互动教程（组件式API-SFC）" class="headerlink" title="互动教程（组件式API+SFC）"></a>互动教程（组件式API+SFC）</h2><h3 id="响应式变量声明方式"><a href="#响应式变量声明方式" class="headerlink" title="响应式变量声明方式"></a>响应式变量声明方式</h3><p>说的明白点，就是动态的数据绑定，在reactive或ref中声明的变量可以响应式地用在html中</p><h4 id="reactive-声明"><a href="#reactive-声明" class="headerlink" title="reactive()声明"></a>reactive()声明</h4><ul><li>reactive只适用于对象（包括数组和内置类型，如Map和Set）</li><li>reactive创建的对象时JS Proxy，行为与普通对象一致</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter.<span class="property">count</span>) <span class="comment">// 0</span></span><br><span class="line">counter.<span class="property">count</span>++</span><br></pre></td></tr></table></figure><h4 id="ref"><a href="#ref" class="headerlink" title="ref()"></a>ref()</h4><ul><li>ref接收任意类型数据</li><li>返回值是一个对象，可以通过对象.value属性访问数据</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> message = <span class="title function_">ref</span>(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="property">value</span>) <span class="comment">// &quot;Hello World!&quot;</span></span><br><span class="line">message.<span class="property">value</span> = <span class="string">&#x27;Changed&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="在模板template中使用响应式状态"><a href="#在模板template中使用响应式状态" class="headerlink" title="在模板template中使用响应式状态"></a>在模板template中使用响应式状态</h3><p>响应式状态暂时我喜欢理解为响应式变量</p><ul><li>使用<code>&#123;&#123;&#125;&#125;</code>使用，并且ref中的对象的value可以不用message.value去访问，而是可以使用message直接访问（因为会被自动解包）</li><li><code>&#123;&#123;&#125;&#125;</code>中不限制于变量名，也可以是表达式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//变量写法</span><br><span class="line">&lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;Count is: &#123;&#123; counter.count &#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">//表达式写法</span><br><span class="line">&lt;h1&gt;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h3 id="Attribute绑定（v-bind）"><a href="#Attribute绑定（v-bind）" class="headerlink" title="Attribute绑定（v-bind）"></a>Attribute绑定（v-bind）</h3><ul><li><p>Attribute n.属性，特质，在编程中通常用来描述数据对象的特征</p></li><li><p>v-bind用于绑定一个动态值，时v-开头的一种特殊Attribute</p></li><li><p>绑定的值可以是calss，可以是id，也可以是一些参数</p></li><li><p>可以简写为<code>:</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//语法糖</span><br><span class="line">&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const titleClass = ref(&#x27;title&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1 :class=&quot;titleClass&quot;&gt;Make me red&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.title &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="事件监听（v-on）"><a href="#事件监听（v-on）" class="headerlink" title="事件监听（v-on）"></a>事件监听（v-on）</h3><ul><li><p>使用v-on监听DOM事件</p></li><li><p>简写为@</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;button v-on:click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">//简写</span><br><span class="line">&lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li><li><p>在script中声明回调函数increment</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const count = ref(0)</span><br><span class="line"></span><br><span class="line">function increment() &#123;</span><br><span class="line">  // 更新组件状态</span><br><span class="line">  count.value++</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="表单的双向绑定"><a href="#表单的双向绑定" class="headerlink" title="表单的双向绑定"></a>表单的双向绑定</h3><h4 id="使用v-bind-v-on"><a href="#使用v-bind-v-on" class="headerlink" title="使用v-bind+v-on"></a>使用v-bind+v-on</h4><p>当v-on监听到表单内容的变化，就使用回调函数获取到表单的新内容，更新数据后，重新响应在v-bind绑定的组件上</p><h4 id="使用v-model（常用于表单、单选、多选、下拉框）"><a href="#使用v-model（常用于表单、单选、多选、下拉框）" class="headerlink" title="使用v-model（常用于表单、单选、多选、下拉框）"></a>使用v-model（常用于表单、单选、多选、下拉框）</h4><ul><li>v-model是实质是上述方法的语法糖</li><li>V-model将绑定的值与input中的值自动同步，不需要在使用事件处理函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//用法</span><br><span class="line">&lt;input v-model=&quot;text&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//例子</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const text = ref(&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input v-model=&quot;text&quot; placeholder=&quot;Type here&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="条件渲染（v-if）"><a href="#条件渲染（v-if）" class="headerlink" title="条件渲染（v-if）"></a>条件渲染（v-if）</h3>]]></content:encoded>
      
      
      
      <category domain="http://shiff.top/tags/Vue/">Vue</category>
      
      
      <comments>http://shiff.top/2024/05/18/vue%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>滑动窗口专项训练</title>
      <link>http://shiff.top/2024/05/16/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/</link>
      <guid>http://shiff.top/2024/05/16/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/</guid>
      <pubDate>Thu, 16 May 2024 15:12:53 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;滑动窗口专项训练&quot;&gt;&lt;a href=&quot;#滑动窗口专项训练&quot; class=&quot;headerlink&quot; title=&quot;滑动窗口专项训练&quot;&gt;&lt;/a&gt;滑动窗口专项训练&lt;/h1&gt;&lt;h2 id=&quot;更新记录&quot;&gt;&lt;a href=&quot;#更新记录&quot; class=&quot;headerlink&quot; </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="滑动窗口专项训练"><a href="#滑动窗口专项训练" class="headerlink" title="滑动窗口专项训练"></a>滑动窗口专项训练</h1><h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>2024.5.17 第一次记录</p><h2 id="一般解题步骤"><a href="#一般解题步骤" class="headerlink" title="一般解题步骤"></a>一般解题步骤</h2><p>待更新</p><p>1.定义需要维护的变量</p><p>可能是：</p><ul><li>哈希表（map或set）</li><li>最短&#x2F;最长长度</li></ul><p>2.初始化滑动窗口，<code>start</code>和<code>end</code>一般都初始化为0（如果是双指针两边夹的情况，一般都是贪心？）</p><ol start="3"><li></li></ol><h2 id="解题模板"><a href="#解题模板" class="headerlink" title="解题模板"></a>解题模板</h2><p>由于自己的理解还不够深刻，这里借鉴大佬的思路</p><p><a href="https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/solutions/879777/hua-dong-chuang-kou-zhen-di-jian-dan-yi-73bii">https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/solutions/879777/hua-dong-chuang-kou-zhen-di-jian-dan-yi-73bii</a></p><p>大佬的是python的版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">problemName</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1: 定义需要维护的变量们 (对于滑动窗口类题目，这些变量通常是最小长度，最大长度，或者哈希表)</span></span><br><span class="line">        x, y = ..., ...</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量, 有的变量需要一个if语句来维护 (比如最大最小长度)</span></span><br><span class="line">            x = new_x</span><br><span class="line">            <span class="keyword">if</span> condition:</span><br><span class="line">                y = new_y</span><br><span class="line"></span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            ------------- 下面是两种情况，读者请根据题意二选1 -------------</span></span><br><span class="line"><span class="string">            &#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="comment"># Step 4 - 情况1</span></span><br><span class="line">            <span class="comment"># 如果题目的窗口长度固定：用一个if语句判断一下当前窗口长度是否超过限定长度 </span></span><br><span class="line">            <span class="comment"># 如果超过了，窗口左指针前移一个单位保证窗口长度固定, 在那之前, 先更新Step 1定义的(部分或所有)维护变量 </span></span><br><span class="line">            <span class="keyword">if</span> 窗口长度大于限定值:</span><br><span class="line">                <span class="comment"># 更新 (部分或所有) 维护变量 </span></span><br><span class="line">                <span class="comment"># 窗口左指针前移一个单位保证窗口长度固定</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4 - 情况2</span></span><br><span class="line">            <span class="comment"># 如果题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 如果当前窗口不合法时, 用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 在左指针移动之前更新Step 1定义的(部分或所有)维护变量 </span></span><br><span class="line">            <span class="keyword">while</span> 不合法:</span><br><span class="line">                <span class="comment"># 更新 (部分或所有) 维护变量 </span></span><br><span class="line">                <span class="comment"># 不断移动窗口左指针直到窗口再次合法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 5: 返回答案</span></span><br><span class="line">        <span class="keyword">return</span> ...</span><br></pre></td></tr></table></figure><p>按照大佬是思路，改成JS的版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> problemName = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="comment">// Step 1: 定义需要维护的变量们 (对于滑动窗口类题目，这些变量通常是最小长度，最大长度，或者哈希表)</span></span><br><span class="line"><span class="keyword">let</span> [x, y] = ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">    <span class="keyword">let</span> st = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> end = <span class="number">0</span>; end &lt; s.<span class="property">length</span>; s++)&#123;</span><br><span class="line">        <span class="comment">//Step 3: 更新需要维护的变量, 有的变量需要一个if语句来维护 (比如最大最小长度)</span></span><br><span class="line">        x = new_x;</span><br><span class="line">      <span class="keyword">if</span>(condition)&#123;</span><br><span class="line">          y = new_y;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// Step 4 - 情况1</span></span><br><span class="line">            <span class="comment">// 如果题目的窗口长度固定：用一个if语句判断一下当前窗口长度是否超过限定长度 </span></span><br><span class="line">            <span class="comment">// 如果超过了，窗口左指针前移一个单位保证窗口长度固定, 在那之前, 先更新Step 1定义的(部分或所有)维护变量 </span></span><br><span class="line">            <span class="keyword">if</span>(窗口长度大于限定值)&#123;</span><br><span class="line">               <span class="comment">// 更新 (部分或所有) 维护变量 </span></span><br><span class="line">                <span class="comment">// 窗口左指针前移一个单位保证窗口长度固定</span></span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">            <span class="comment">// Step 4 - 情况2</span></span><br><span class="line">            <span class="comment">// 如果题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment">// 如果当前窗口不合法时, 用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment">// 在左指针移动之前更新Step 1定义的(部分或所有)维护变量 </span></span><br><span class="line">            <span class="keyword">while</span>(不合法)&#123;</span><br><span class="line">            <span class="comment">//更新 (部分或所有) 维护变量 </span></span><br><span class="line">              <span class="comment">//不断移动窗口左指针直到窗口再次合法</span></span><br><span class="line">            &#125;           </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// Step 5: 返回答案</span></span><br><span class="line">  <span class="keyword">return</span> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="实战训练"><a href="#实战训练" class="headerlink" title="实战训练"></a>实战训练</h2><h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><p><strong>code:</strong></p><p>不用map，用set和单纯数组都行，数组的话就用include方法来查看字母是否已经存在于数组中，但是最好还是不要数组了，数组里面删除一个元素会很麻烦，主要还是哈希+滑动窗口的思想。</p><p>用set的话会简单一点点</p><p>带注释版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//无重复字符的最长子串</span></span><br><span class="line">    <span class="comment">//ex</span></span><br><span class="line">    <span class="comment">// abcabcbb</span></span><br><span class="line">    <span class="comment">// abc -&gt; maxLen = 3</span></span><br><span class="line">    <span class="comment">//滑动窗口</span></span><br><span class="line">    <span class="comment">//1.定义需要维护的变量</span></span><br><span class="line">    <span class="keyword">let</span> maxLen = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> hash = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="comment">//2.定义窗口的首尾端，然后滑动窗口</span></span><br><span class="line">    <span class="keyword">let</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> end = <span class="number">0</span>; end &lt; s.<span class="property">length</span>; end++)&#123;<span class="comment">//第一次debug是end++写成s++了</span></span><br><span class="line">        <span class="comment">//维护变量</span></span><br><span class="line">        <span class="keyword">let</span> c = s[end];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//情况2:窗口可变,检查窗口是否合法，不合法就调整st指针直至合法  </span></span><br><span class="line">        <span class="comment">//在该题目中，不合法指的是，字符串中出现重复字符 </span></span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="title function_">has</span>(c))&#123;<span class="comment">//c字符不是第一次出现，窗口不合法</span></span><br><span class="line">            <span class="comment">//只要连续移动字符，直到新的窗口的字符中不包含第一次出现的c字符位置</span></span><br><span class="line">            <span class="keyword">while</span>( st &lt; end &amp;&amp; s[st] != c)&#123;</span><br><span class="line">                hash.<span class="title function_">delete</span>(s[st]);<span class="comment">//第二次debug，这一句和下面一句的顺序反了，如果先++在delet，那么相当于delet的是下一个字符，第一个字符永远都不会被移除</span></span><br><span class="line">                st++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//此时的st应该位于第一个窗口的第一个c字符处</span></span><br><span class="line">            st++;</span><br><span class="line">            <span class="comment">//现在窗口合法了</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//第一次出现</span></span><br><span class="line">            hash.<span class="title function_">set</span>(c, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//窗口的长度为end - st + 1 （左闭右闭区间）</span></span><br><span class="line">        <span class="comment">//如果是左闭右开区间，就是end - st</span></span><br><span class="line">        maxLen = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLen, end - st + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不带注释</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> maxLen = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> hash = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> end = <span class="number">0</span>; end &lt; s.<span class="property">length</span>; end++)&#123;</span><br><span class="line">        <span class="keyword">let</span> c = s[end];    </span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">            <span class="keyword">while</span>( st &lt; end &amp;&amp; s[st] != c)&#123;</span><br><span class="line">                hash.<span class="title function_">delete</span>(s[st]);</span><br><span class="line">                st++;</span><br><span class="line">            &#125; </span><br><span class="line">            st++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            hash.<span class="title function_">set</span>(c, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLen, end - st + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h3><p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></p><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span><br></pre></td></tr></table></figure><p> <strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;, p = &quot;ab&quot;</span><br><span class="line">输出: [0,1,2]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br></pre></td></tr></table></figure><p><strong>Code:</strong></p><p>窗口不合理的情况比较复杂</p><p>带注释版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">p</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findAnagrams = <span class="keyword">function</span>(<span class="params">s, p</span>) &#123;</span><br><span class="line">    <span class="comment">//哈希(异位词)+滑动窗口(子串)</span></span><br><span class="line">    <span class="comment">//异位词的特点是：</span></span><br><span class="line">    <span class="comment">//1.长度相等</span></span><br><span class="line">    <span class="comment">//2.每个字符的出现次数相等</span></span><br><span class="line">    <span class="keyword">let</span> hash = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> hash2 = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="comment">//初始化hash</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; p.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="title function_">has</span>(p[i]))&#123;</span><br><span class="line">            hash.<span class="title function_">set</span>(p[i], hash.<span class="title function_">get</span>(p[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> hash.<span class="title function_">set</span>(p[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化窗口，并开始滑动</span></span><br><span class="line">    <span class="keyword">let</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> end = <span class="number">0</span>; end &lt; s.<span class="property">length</span>; end++)&#123;</span><br><span class="line">        <span class="keyword">let</span> c = s[end];</span><br><span class="line">        <span class="keyword">if</span>(hash2.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">            hash2.<span class="title function_">set</span>(c, hash2.<span class="title function_">get</span>(c) + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> hash2.<span class="title function_">set</span>(c, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//窗口不合法1，没有这个字符,两个指针都跳到这个指针后面</span></span><br><span class="line">        <span class="keyword">if</span>(!hash.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">            <span class="keyword">while</span>(st != end + <span class="number">1</span>)&#123;<span class="comment">//debug1,一开始没有跳转到st = end+1，只是st++，这样是不对的，而且跳转完之后，一定要记得移除hash2中前面的（已经不在滑动窗口中的）字母</span></span><br><span class="line">                hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);</span><br><span class="line">                st++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(hash2.<span class="title function_">get</span>(c) &gt; hash.<span class="title function_">get</span>(c))&#123;</span><br><span class="line">            <span class="comment">//窗口不合法2,有这个字符，但是字符数多了,移动st，直到窗口中的c的字符数与hash中的字符数一致</span></span><br><span class="line">            <span class="keyword">while</span>(hash2.<span class="title function_">get</span>(c) != hash.<span class="title function_">get</span>(c))&#123;</span><br><span class="line">                hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);</span><br><span class="line">                st++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//窗口不合法3，窗口长度超过了</span></span><br><span class="line">        <span class="keyword">while</span>(end - st + <span class="number">1</span> &gt; p.<span class="property">length</span>)&#123;</span><br><span class="line">            hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);<span class="comment">//debug2，滑动了窗口，但是忘记处理hash2了</span></span><br><span class="line">            st++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(end - st + <span class="number">1</span> === p.<span class="property">length</span>)&#123;</span><br><span class="line">            res.<span class="title function_">push</span>(st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不带注释版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">p</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findAnagrams = <span class="keyword">function</span>(<span class="params">s, p</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> hash = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> hash2 = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; p.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="title function_">has</span>(p[i]))&#123;</span><br><span class="line">            hash.<span class="title function_">set</span>(p[i], hash.<span class="title function_">get</span>(p[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> hash.<span class="title function_">set</span>(p[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> end = <span class="number">0</span>; end &lt; s.<span class="property">length</span>; end++)&#123;</span><br><span class="line">        <span class="keyword">let</span> c = s[end];</span><br><span class="line">        <span class="keyword">if</span>(hash2.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">            hash2.<span class="title function_">set</span>(c, hash2.<span class="title function_">get</span>(c) + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> hash2.<span class="title function_">set</span>(c, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!hash.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">            <span class="keyword">while</span>(st != end + <span class="number">1</span>)&#123;</span><br><span class="line">                hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);</span><br><span class="line">                st++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(hash2.<span class="title function_">get</span>(c) &gt; hash.<span class="title function_">get</span>(c))&#123;</span><br><span class="line">            <span class="keyword">while</span>(hash2.<span class="title function_">get</span>(c) != hash.<span class="title function_">get</span>(c))&#123;</span><br><span class="line">                hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);</span><br><span class="line">                st++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(end - st + <span class="number">1</span> &gt; p.<span class="property">length</span>)&#123;</span><br><span class="line">            hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);</span><br><span class="line">            st++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(end - st + <span class="number">1</span> === p.<span class="property">length</span>)&#123;</span><br><span class="line">            res.<span class="title function_">push</span>(st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="http://shiff.top/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      <category domain="http://shiff.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      
      <comments>http://shiff.top/2024/05/16/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>动态规划专项训练</title>
      <link>http://shiff.top/2024/05/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/</link>
      <guid>http://shiff.top/2024/05/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/</guid>
      <pubDate>Mon, 13 May 2024 06:51:24 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;动态规划专项训练&quot;&gt;&lt;a href=&quot;#动态规划专项训练&quot; class=&quot;headerlink&quot; title=&quot;动态规划专项训练&quot;&gt;&lt;/a&gt;动态规划专项训练&lt;/h1&gt;&lt;p&gt;参考：代码随想录官⽹&lt;a href=&quot;http://www.programmercarl.c</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="动态规划专项训练"><a href="#动态规划专项训练" class="headerlink" title="动态规划专项训练"></a>动态规划专项训练</h1><p>参考：代码随想录官⽹<a href="http://www.programmercarl.com/">www.programmercarl.com</a></p><h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>第一次更新 2024.05.13</p><p>第二次更新 2024.05.17</p><h2 id="一般解题步骤"><a href="#一般解题步骤" class="headerlink" title="一般解题步骤"></a>一般解题步骤</h2><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>​dp数组（状态转移数组）可以是一维的可以是二维的</p><ol start="2"><li>确定递推公式 （状态转移方程）</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><h2 id="实战训练"><a href="#实战训练" class="headerlink" title="实战训练"></a>实战训练</h2><h3 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h3><h4 id="1-斐波那契数"><a href="#1-斐波那契数" class="headerlink" title="1.斐波那契数"></a>1.斐波那契数</h4><p><a href="https://leetcode.cn/problems/fibonacci-number/">509. 斐波那契数</a></p><p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0，F(1) = 1</span><br><span class="line">F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure><p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) = F(1) + F(0) = 1 + 0 = 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) = F(2) + F(1) = 1 + 1 = 2</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：3</span><br><span class="line">解释：F(4) = F(3) + F(2) = 2 + 1 = 3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 30</code></li></ul><p><strong>code：</strong></p><p>用模拟的思想做的，非dp</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fib = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> num1 = <span class="number">0</span>, num2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> cur;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cur = num1 + num2;</span><br><span class="line">        num1 = num2;</span><br><span class="line">        num2 = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>用动态规划来做</strong></p><ol><li><p>确定dp数组（dp table）以及下标的含义 </p><p>dp[i]表示第i个斐波那契数</p></li><li><p>确定递推公式</p><p>题目 中有 dp[i] &#x3D; dp[i - 1] + dp[i - 2]</p></li><li><p>dp数组如何初始化</p><p>题目中有 dp[0] &#x3D; 0 , dp[1] &#x3D; 1</p></li><li><p>确定遍历顺序</p><p>是从后向前还是从前向后，是一层还是两层，如果是两层，哪层在外面</p></li><li><p>打印推导dp数组（debug用的）</p></li></ol><h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h4><p><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></p><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><p><strong>code：</strong></p><p>在前面知识的基础上，我大概能了解到迈上第n阶的方法其实是有前面的迈上n-1和迈上n-2阶的种数有关的，但是如果没有关键点的想，很容易想岔去。</p><p>下面的代码是我第一个自己思考的代码，是错误的，一开始想的是想的是比如想要到第4阶，有可能是dp[1] + dp[3], dp[2]+ dp[2], dp[3] + dp[1]；但是如果这样想的话，所有种类中是会有重复值的。所以我也想到了要去重，但是去重的规律并没有找对；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="comment">//dp[i]表示爬到i阶楼梯，有dp[i]种方法</span></span><br><span class="line">    <span class="keyword">let</span> dp = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="comment">//初始化dp[]</span></span><br><span class="line">    <span class="comment">//状态转移方程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> cn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> k = <span class="number">1</span>; k &lt; i; k++)&#123;</span><br><span class="line">            cn += (dp[k] * dp[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//去除重复值</span></span><br><span class="line">        cn = cn - <span class="number">2</span> * i + <span class="number">5</span>;</span><br><span class="line">        dp.<span class="title function_">push</span>(cn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看了卡哥的视频解说，反复想了一下理解了，其实思路是可以有很多种的，但是如果想用动态规划的思路来写，关键点在于<code>状态转移</code>，如果从0阶开始向上迈，那么状态转移方程其实很不好把握，容易像我之前一样想岔了，会想：先走几阶有几种方法，后走几阶有几种方法，很容易把自己绕进去。</p><p>但是如果想要专注于状态转移，应该<strong>从台阶上往下看</strong>，而且必须注意状态转移的条件（即每次只能爬1或2个台阶），那么对于一个人来说，他走到n层台阶的上一个状态只可能有两种：</p><ol><li>上一个状态是走到了n-1个台阶，他是迈了一步才走到n台阶的</li><li>上一个状态是走到了n-2个台阶，他是迈了两步才走到n台阶的</li></ol><p>可以想到，这样递归出来的种类数其实是很干净的，不会存在重复值，因为不同于我第一次的想法，我第一次想的是（**step1:**从0-k有几种方法； **step2:**从k-n有几种方法），而动态规划中，强制了我的step2只能有一种方法。举个例子:</p><p>易得dp[1] &#x3D; 1, dp[2]&#x3D; 2</p><p>如果我想求dp[4]</p><p>先看看我原本的想法：可能性有先走一步，再走三步；先走二步，再走两步；先走三步，再走一步</p><p>那么这个<code>dp[4]=dp[1]*dp[3]+ dp[2]*dp[2]+dp[3]*dp[1]</code>，但是这样的递归推导是不干净的，因为里面存在了很多的重复值</p><p>再看看动态规划的思想：如果我想根据step1+step2的思路来思考的话，首先强制step2的方法只能有一种，即当走过step1方法到达中间的某个台阶后，我只能通过一种方法来到达台阶n。</p><p>虽然step只能有一种方法，但是step可以有两种情况：即先走 2步，然后走2步到n；或者先走3步，然后走1步到n；</p><p>由此可得到：dp[4] &#x3D; d[2] * 1 + d[3] * 1;</p><p>所以我才得出了dp的关键在于：到达这个状态的上一个状态是怎么样的，因为上一个状态总是通过一次操作（一次状态转移）达到这个状态，这样递归下来的数据才是干净的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="comment">//dp[i]表示爬到i阶楼梯，有dp[i]种方法</span></span><br><span class="line">    <span class="keyword">let</span> dp = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="comment">//状态转移方程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        dp.<span class="title function_">push</span>(dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]);<span class="comment">//可以不用维护数组，直接用变量来写，写法上一题斐波那契数写法一致，不写了这里</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h4><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></p><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [10,15,20]</span><br><span class="line">输出：15</span><br><span class="line">解释：你将从下标为 1 的台阶开始。</span><br><span class="line">- 支付 15 ，向上爬两个台阶，到达楼梯顶部。</span><br><span class="line">总花费为 15 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [1,100,1,1,1,100,1,1,100,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：你将从下标为 0 的台阶开始。</span><br><span class="line">- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。</span><br><span class="line">- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。</span><br><span class="line">- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。</span><br><span class="line">- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。</span><br><span class="line">- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。</span><br><span class="line">- 支付 1 ，向上爬一个台阶，到达楼梯顶部。</span><br><span class="line">总花费为 6 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= cost.length &lt;= 1000</code></li><li><code>0 &lt;= cost[i] &lt;= 999</code></li></ul><p><strong>Code:</strong></p><p>这道题的难点在于搞清楚<code>ct[i]</code>到底指的是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">cost</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ct[i]指的是到达i（此时i是楼顶）的最小消费</span></span><br><span class="line"><span class="keyword">var</span> minCostClimbingStairs = <span class="keyword">function</span>(<span class="params">cost</span>) &#123;</span><br><span class="line">    <span class="comment">//ct[i]达到i台阶的需要最小消费</span></span><br><span class="line">    <span class="keyword">if</span>(cost.<span class="property">length</span>==<span class="number">1</span>) <span class="keyword">return</span> cost[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(cost.<span class="property">length</span>==<span class="number">2</span>) <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">min</span>(cost[<span class="number">0</span>],cost[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">let</span> ct1 = <span class="title class_">Math</span>.<span class="title function_">min</span>(cost[<span class="number">0</span>],cost[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">let</span> ct = [<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= cost.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> cur = <span class="title class_">Math</span>.<span class="title function_">min</span>(ct[i - <span class="number">1</span>]+cost[i - <span class="number">1</span>], ct[i-<span class="number">2</span>]+cost[i-<span class="number">2</span>]);</span><br><span class="line">        ct.<span class="title function_">push</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ct[ct.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="不同路径【Mid】"><a href="#不同路径【Mid】" class="headerlink" title="不同路径【Mid】"></a>不同路径【Mid】</h4><p><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></p><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>示例 1：</strong></p><p><img src="https://pic.leetcode.cn/1697422740-adxmsI-image.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向下</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 7, n = 3</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><h5 id="用dp来写"><a href="#用dp来写" class="headerlink" title="用dp来写"></a>用dp来写</h5><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><p>d[x][y]表示从start开始到点（x,y）有d[x][y]种走法</p><p>关键点在于只能向下走或者向右走，所以x和y都智能递增，是不可能回头的，所以对于边缘d[x][1]和d[1][y]都应该初始化为1；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">m</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> uniquePaths = <span class="keyword">function</span>(<span class="params">m, n</span>) &#123;</span><br><span class="line">    <span class="comment">//初始化d[x][y]边缘元素为1</span></span><br><span class="line">    <span class="keyword">let</span> d = <span class="keyword">new</span> <span class="title class_">Array</span>(m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="number">1</span>; x &lt;= m; x++)&#123;</span><br><span class="line">        d[x] = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span>) d[<span class="number">1</span>].<span class="title function_">fill</span>(<span class="number">1</span>);</span><br><span class="line">        d[x][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="number">2</span>; x &lt;= m; x++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> y = <span class="number">2</span>; y &lt;= n; y++)&#123;</span><br><span class="line">            d[x][y] = d[x][y - <span class="number">1</span>] + d[x - <span class="number">1</span>][y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(d);</span><br><span class="line">    <span class="keyword">return</span> d[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="DFS的基本写法"><a href="#DFS的基本写法" class="headerlink" title="DFS的基本写法"></a>DFS的基本写法</h5><p>在JavaScript中，深度优先搜索（DFS）的一般写法与其他编程语言类似。下面是一个基本的DFS函数示例，用于在一个图或树结构中进行深度优先搜索：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">node, visited</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (visited.<span class="title function_">has</span>(node)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理当前节点</span></span><br><span class="line">    visited.<span class="title function_">add</span>(node);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历当前节点的相邻节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> neighbor <span class="keyword">of</span> node.<span class="property">neighbors</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited.<span class="title function_">has</span>(neighbor)) &#123;</span><br><span class="line">            <span class="title function_">dfs</span>(neighbor, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化访问记录</span></span><br><span class="line"><span class="keyword">let</span> visited = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从起始节点开始进行DFS</span></span><br><span class="line"><span class="title function_">dfs</span>(startNode, visited);</span><br></pre></td></tr></table></figure><p>在这段代码中，<code>dfs()</code>函数表示深度优先搜索的递归函数，接受一个节点<code>node</code>和一个记录访问情况的<code>visited</code>集合作为参数。在DFS过程中，首先检查当前节点是否已经被访问过，如果已经访问过则直接返回；否则将当前节点标记为已访问，并递归地对当前节点的相邻节点进行DFS遍历。</p><p>用dfs,会超时，时间复杂度会达到2^(m+n)次，所以不合适，但是思路是可行的，如果m和n较小的话</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">m</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> uniquePaths = <span class="keyword">function</span>(<span class="params">m, n</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果越界，则认为这条路径不可行</span></span><br><span class="line">        <span class="keyword">if</span> (x &gt;= m || y &gt;= n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当到达终点时，返回1</span></span><br><span class="line">        <span class="keyword">if</span> (x === m - <span class="number">1</span> &amp;&amp; y === n - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 向右走 + 向下走</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">dfs</span>(x + <span class="number">1</span>, y) + <span class="title function_">dfs</span>(x, y + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="不同路径II"><a href="#不同路径II" class="headerlink" title="不同路径II"></a>不同路径II</h4><p><a href="https://leetcode.cn/problems/unique-paths-ii/">63. 不同路径 II</a></p><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]</span><br><span class="line">输出：2</span><br><span class="line">解释：3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacleGrid = [[0,1],[0,0]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == obstacleGrid.length</code></li><li><code>n == obstacleGrid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">obstacleGrid</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> uniquePathsWithObstacles = <span class="keyword">function</span>(<span class="params">obstacleGrid</span>) &#123;</span><br><span class="line">    <span class="comment">//当（x,y）点是障碍点时，那么达到x,y的路径只能是0条，多加一个判断条件</span></span><br><span class="line">    <span class="comment">//初始化d[x][y]</span></span><br><span class="line">    <span class="keyword">let</span> m = obstacleGrid.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> n = obstacleGrid[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> d = <span class="keyword">new</span> <span class="title class_">Array</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; m; x++)&#123;</span><br><span class="line">        d[x] = <span class="keyword">new</span> <span class="title class_">Array</span>(n);</span><br><span class="line">        <span class="keyword">let</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x==<span class="number">0</span> &amp;&amp; obstacleGrid[<span class="number">0</span>][y]!=<span class="number">1</span> &amp;&amp; y &lt; n)&#123;</span><br><span class="line">            d[<span class="number">0</span>][y++] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(x==<span class="number">0</span> &amp;&amp; y &lt; n)&#123;</span><br><span class="line">            d[<span class="number">0</span>][y++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[x][<span class="number">0</span>]!=<span class="number">1</span>)&#123;</span><br><span class="line">            d[x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(x &lt; m)&#123;<span class="comment">//这里有个易错点</span></span><br><span class="line">              <span class="comment">//如果在这个代码块种不加if(x &lt; m)d[x] = new Array(n);，那么因为当x++的时候，下一个d[x]是没有定义为数组的，如果此时使用d[x][0]就会报不能给undefined赋值的错误</span></span><br><span class="line">                d[x][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                x++;</span><br><span class="line">                <span class="keyword">if</span>(x &lt; m)d[x] = <span class="keyword">new</span> <span class="title class_">Array</span>(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="number">1</span>; x &lt; m; x++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> y = <span class="number">1</span>; y &lt; n; y++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[x][y]==<span class="number">1</span>)&#123;</span><br><span class="line">                d[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                d[x][y] = d[x-<span class="number">1</span>][y] + d[x][y-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(d);</span><br><span class="line">    <span class="keyword">return</span> d[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="http://shiff.top/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      <category domain="http://shiff.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</category>
      
      
      <comments>http://shiff.top/2024/05/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>leetcode热题hot100</title>
      <link>http://shiff.top/2024/05/12/leetcode%E7%83%AD%E9%A2%98hot100/</link>
      <guid>http://shiff.top/2024/05/12/leetcode%E7%83%AD%E9%A2%98hot100/</guid>
      <pubDate>Sun, 12 May 2024 15:24:52 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;leetcode热题hot100【JS】&quot;&gt;&lt;a href=&quot;#leetcode热题hot100【JS】&quot; class=&quot;headerlink&quot; title=&quot;leetcode热题hot100【JS】&quot;&gt;&lt;/a&gt;leetcode热题hot100【JS】&lt;/h1&gt;&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="leetcode热题hot100【JS】"><a href="#leetcode热题hot100【JS】" class="headerlink" title="leetcode热题hot100【JS】"></a>leetcode热题hot100【JS】</h1><h2 id="更新时间"><a href="#更新时间" class="headerlink" title="更新时间"></a>更新时间</h2><p>2024.5.12 第一次更新</p><p>2024.5.17 第二次更新</p><h2 id="刷算法题可能用到的函数和表示方式"><a href="#刷算法题可能用到的函数和表示方式" class="headerlink" title="刷算法题可能用到的函数和表示方式"></a>刷算法题可能用到的函数和表示方式</h2><h3 id="常用的表达方式"><a href="#常用的表达方式" class="headerlink" title="常用的表达方式"></a>常用的表达方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2的10次方</span></span><br><span class="line"><span class="keyword">let</span> n = <span class="number">2</span> ** <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组中插入数据</span></span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//arr = [1]</span></span><br><span class="line">arr.<span class="title function_">indexOf</span>(<span class="number">1</span>);<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//比较两个数组是否相等（只适用于数组里面的元素都是原始值）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arraysAreEqual</span>(<span class="params">array1, array2</span>) &#123;</span><br><span class="line">    <span class="comment">// 首先检查数组长度</span></span><br><span class="line">    <span class="keyword">if</span> (array1.<span class="property">length</span> !== array2.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后检查每个元素是否相等</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array1.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array1[i] !== array2[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果通过了上述检查，那么数组相等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组遍历</span></span><br><span class="line"><span class="keyword">let</span> strs = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strs.<span class="property">length</span>; i++)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i,strs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用for of 与entries()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [i, str] <span class="keyword">of</span> strs.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数字数组的排序</span></span><br><span class="line"><span class="comment">//在JavaScript中，如果sort()方法没有提供比较函数，它会将数组元素转换成字符串，然后按照字符串的Unicode码点顺序进行排序。</span></span><br><span class="line"><span class="comment">//会导致例如这个数组[100,4,200,1,3,2]排序不成功</span></span><br><span class="line"><span class="comment">//例如，数字100和200在转换为字符串后，会根据它们的第一个字符（&quot;1&quot;和&quot;2&quot;）来进行排序，但当比较2和100时，由于&quot;2&quot;的Unicode码点小于&quot;1&quot;的Unicode码点，所以2会排在100之前。</span></span><br><span class="line"><span class="comment">//需要加入比较函数</span></span><br><span class="line">nums = [<span class="number">100</span>,<span class="number">4</span>,<span class="number">200</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>];</span><br><span class="line">nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"><span class="comment">//这个比较函数简单地从a中减去b。如果结果是负数，那么a将排在b之前；如果结果是正数，b将排在a之前；如果结果是0，那么它们的顺序不变。</span></span><br><span class="line"><span class="comment">// a-b就是 从小到大排序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个长度为n，值为0的数组</span></span><br><span class="line"><span class="keyword">let</span> n = <span class="number">5</span>; <span class="comment">// 假设我们想要一个长度为5的数组</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// 输出: [0, 0, 0, 0, 0]</span></span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单个字符转换成ASCII码字</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">ASCIINum</span> = c.<span class="title function_">charCodeAt</span>(<span class="number">0</span>);<span class="comment">//97</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c1 = <span class="string">&#x27;ab&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">ASCIINum</span> = c.<span class="title function_">charCodeAt</span>(<span class="number">2</span>);<span class="comment">//98</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串分割成单个字符的数组</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">char</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(char));</span><br><span class="line"><span class="comment">// [&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串字母排序 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sortString</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="comment">// 将字符串转换为数组</span></span><br><span class="line">    <span class="keyword">let</span> arr = str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="comment">// 对数组进行排序</span></span><br><span class="line">    arr.<span class="title function_">sort</span>();</span><br><span class="line">    <span class="comment">// 将数组转换回字符串</span></span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> originalString = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> sortedString = <span class="title function_">sortString</span>(originalString);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sortedString); <span class="comment">// 输出: ehllo</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>在JavaScript中，<code>Map</code> 是一种新的数据结构，它允许你存储键值对（key-value pairs）。与对象不同，<code>Map</code> 的键可以是任何类型的值，包括函数、对象或任何原始类型。下面是一些基本的 <code>Map</code> 对象用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 `has` 方法可以检查 `Map` 中是否存在某个键：</span></span><br><span class="line"><span class="comment">//创建一个 Map</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置键值对</span></span><br><span class="line"><span class="comment">//使用 `set` 方法可以添加或更新键值对：</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">map.<span class="title function_">set</span>(&#123;&#125;, <span class="string">&#x27;Object&#x27;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;, <span class="string">&#x27;Function&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(<span class="string">&#x27;key&#x27;</span>)); <span class="comment">// 输出: &#x27;value&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(<span class="number">123</span>)); <span class="comment">// 输出: 456</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查键是否存在</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">has</span>(<span class="string">&#x27;key&#x27;</span>)); <span class="comment">// 输出: true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">has</span>(<span class="string">&#x27;notExist&#x27;</span>)); <span class="comment">// 输出: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除键值对</span></span><br><span class="line">map.<span class="title function_">delete</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Map的大小</span></span><br><span class="line"><span class="comment">//使用 `size` 属性可以获取 `Map` 中键值对的数量：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">size</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历Map</span></span><br><span class="line"><span class="comment">//`Map` 对象可以通过 `forEach` 方法遍历，也可以使用迭代器方法（如 `keys()`, `values()`, 和 `entries()`）进行遍历。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 `forEach` 遍历：</span></span><br><span class="line">map.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用迭代器遍历：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者直接遍历Map对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空Map</span></span><br><span class="line">map.<span class="title function_">clear</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>在JavaScript中，<code>Set</code>是一种新的数据结构，它类似于数组，但是它的一个主要特点是其内部的值都是唯一的，没有重复的值。<code>Set</code>对象允许你存储任何类型的唯一值，无论是原始值或是对象引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个 Set</span></span><br><span class="line"><span class="keyword">let</span> mySet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以在创建时初始化`Set`：</span></span><br><span class="line"><span class="keyword">let</span> mySet = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mySet); <span class="comment">// Set(4) &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，即使数组中包含重复的元素，`Set`仍然确保只保存唯一的值。</span></span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">mySet.<span class="title function_">add</span>(<span class="number">5</span>);</span><br><span class="line">mySet.<span class="title function_">add</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">mySet.<span class="title function_">add</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查元素</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mySet.<span class="title function_">has</span>(<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mySet.<span class="title function_">has</span>(<span class="number">6</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">mySet.<span class="title function_">delete</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历 Set</span></span><br><span class="line"><span class="comment">//`Set`对象可以使用`forEach()`方法和`for...of`循环来遍历：</span></span><br><span class="line">mySet.<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> mySet) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 Set 的大小</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mySet.<span class="property">size</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空 Set</span></span><br><span class="line">mySet.<span class="title function_">clear</span>();</span><br></pre></td></tr></table></figure><blockquote><p>Set是JavaScript ES6中引入的一种集合类型，它提供了一种存储唯一值的高效方式。</p></blockquote><h2 id="100题实战"><a href="#100题实战" class="headerlink" title="100题实战"></a>100题实战</h2><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><h4 id="两数之和【数组、哈希】"><a href="#两数之和【数组、哈希】" class="headerlink" title="两数之和【数组、哈希】"></a>两数之和【数组、哈希】</h4><p><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></p><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p><strong>code</strong>:</p><p>第一次写没有考虑到两个数的下标不能一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> res = [];</span><br><span class="line">        <span class="keyword">let</span> index;</span><br><span class="line">        <span class="keyword">if</span>(( index = nums.<span class="title function_">indexOf</span>(target - nums[i])) != -<span class="number">1</span> &amp;&amp; index != i)&#123;</span><br><span class="line">            res.<span class="title function_">push</span>(i);</span><br><span class="line">            res.<span class="title function_">push</span>(index);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="字母异位词分组【数组、哈希、字符串】"><a href="#字母异位词分组【数组、哈希、字符串】" class="headerlink" title="字母异位词分组【数组、哈希、字符串】"></a>字母异位词分组【数组、哈希、字符串】</h4><p><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></p><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;&quot;]</span><br><span class="line">输出: [[&quot;&quot;]]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;a&quot;]</span><br><span class="line">输出: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅包含小写字母</li></ul><p><strong>code</strong></p><p>一开始的想法是对每一个字符串的ASCII码求和，和一样的字符串就是字母异位词，但是仔细想一下就知道这样不对，即使字符不一样，也可能会出现SASCII码一样的情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string[]</span>&#125; <span class="variable">strs</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> groupAnagrams = <span class="keyword">function</span>(<span class="params">strs</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> hash = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strs.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//遍历每一个字符串</span></span><br><span class="line">        <span class="keyword">let</span> sumASCII = <span class="number">0</span>;</span><br><span class="line">        strs[i].<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">c</span> =&gt;</span> sumASCII += c.<span class="title function_">charCodeAt</span>(<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="title function_">has</span>(sumASCII))&#123;<span class="comment">//存在同样的</span></span><br><span class="line">            <span class="keyword">let</span> arr = hash.<span class="title function_">get</span>(sumASCII);</span><br><span class="line">            arr.<span class="title function_">push</span>(strs[i]);</span><br><span class="line">            hash.<span class="title function_">set</span>(sumASCII, arr);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> arr = [];</span><br><span class="line">            arr.<span class="title function_">push</span>(strs[i]);</span><br><span class="line">            hash.<span class="title function_">set</span>(sumASCII,arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    hash.<span class="title function_">forEach</span>( <span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(value);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看了官方解法,有两种解法，排序和计数，很好的解法</p><p><strong>排序</strong></p><p>思路和上面的ASCII码的思路是一样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string[]</span>&#125; <span class="variable">strs</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> groupAnagrams = <span class="keyword">function</span>(<span class="params">strs</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> mp = <span class="keyword">new</span> <span class="title class_">Map</span>();<span class="comment">//哈希表，&lt;str, arr&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> [i, str] <span class="keyword">of</span> strs.<span class="title function_">entries</span>())&#123;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">let</span> arr = str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">sort</span>();</span><br><span class="line">        <span class="keyword">let</span> newStr = arr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="title function_">has</span>(newStr))&#123;<span class="comment">//存过了</span></span><br><span class="line">            <span class="keyword">let</span> subArr = mp.<span class="title function_">get</span>(newStr);</span><br><span class="line">            subArr.<span class="title function_">push</span>(str);</span><br><span class="line">            mp.<span class="title function_">set</span>(newStr, subArr);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> subArr = [];</span><br><span class="line">            subArr.<span class="title function_">push</span>(str);</span><br><span class="line">            mp.<span class="title function_">set</span>(newStr, subArr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    mp.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> res.<span class="title function_">push</span>(value));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="【要二刷】最长连续序列【并查集、数组、哈希表】"><a href="#【要二刷】最长连续序列【并查集、数组、哈希表】" class="headerlink" title="【要二刷】最长连续序列【并查集、数组、哈希表】"></a>【要二刷】最长连续序列【并查集、数组、哈希表】</h4><p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></p><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><p>思路是哈希表，但是刚开始没有想到有负数，通过用例 67&#x2F;75</p><p>主要是超过时间限制了，10的9次方的数，遍历一遍就超时了</p><p>单出用hashtable[num]++;来计数判断不行了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//个别用例超时</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestConsecutive = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="property">length</span>===<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> maxNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> minNum = <span class="number">0</span>;</span><br><span class="line">    nums.<span class="title function_">map</span>( <span class="function">(<span class="params">v</span>) =&gt;</span>&#123;</span><br><span class="line">        maxNum = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxNum, v);</span><br><span class="line">        minNum = <span class="title class_">Math</span>.<span class="title function_">min</span>(minNum, v);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">let</span> hashTable1 = <span class="title class_">Array</span>(maxNum + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> hashTable2</span><br><span class="line">    <span class="keyword">if</span>(minNum &lt; <span class="number">0</span>)&#123;<span class="comment">//有负数</span></span><br><span class="line">        hashTable2 = <span class="title class_">Array</span>( -<span class="number">1</span> * minNum + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            hashTable1[nums[i]]++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            hashTable2[ -<span class="number">1</span> * nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> maxLen1 = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> maxLen2 = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> l1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> l2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//正数</span></span><br><span class="line">    <span class="keyword">let</span> f1 = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= maxNum ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hashTable1[i] != <span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//有中断</span></span><br><span class="line">            f1 = <span class="literal">true</span>;</span><br><span class="line">            maxLen1 = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLen1, res);</span><br><span class="line">            res = <span class="number">0</span>;<span class="comment">//重新计数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!f1) l1++;</span><br><span class="line">    &#125;</span><br><span class="line">    maxLen1 = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLen1, res);</span><br><span class="line">    <span class="comment">//负数</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> f2 = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= ( -<span class="number">1</span> * minNum) ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hashTable2[i] != <span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//有中断</span></span><br><span class="line">            f2 = <span class="literal">true</span>;</span><br><span class="line">            maxLen2 = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLen2, res);</span><br><span class="line">            res = <span class="number">0</span>;<span class="comment">//重新计数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!f2) l1++;    </span><br><span class="line">    &#125;</span><br><span class="line">    maxLen2 = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLen2, res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算负-0-正</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLen1, maxLen2, l1+l2);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>稍微看了一下题解思路，说是主要判断这个数的上一个数是否在哈希表中，感觉有点思路了，尝试写一下,没写出来，看完题解思路了才写的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestConsecutive = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> mySet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    nums.<span class="title function_">map</span>( <span class="function"><span class="params">v</span> =&gt;</span> &#123;mySet.<span class="title function_">add</span>(v);&#125;);</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>, cn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//判断该数字是否是连续子串的开头</span></span><br><span class="line">        cn = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!mySet.<span class="title function_">has</span>(nums[i] - <span class="number">1</span>))&#123;<span class="comment">//是开头</span></span><br><span class="line">            <span class="keyword">let</span> st = nums[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(mySet.<span class="title function_">has</span>(st))&#123;</span><br><span class="line">                cn++;</span><br><span class="line">                st++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="title class_">Math</span>.<span class="title function_">max</span>(res, cn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="移动零【数组、双指针】"><a href="#移动零【数组、双指针】" class="headerlink" title="移动零【数组、双指针】"></a>移动零【数组、双指针】</h4><p><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></p><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure><p><strong>提示</strong>:</p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><p><strong>进阶：</strong>你能尽量减少完成的操作次数吗？</p><p><strong>code</strong></p><p>快慢指针的思路</p><p>慢指针指向待更新的数</p><p>快指针指向非0需要转移的数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> moveZeroes = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="comment">// 0 1 0 3 12</span></span><br><span class="line">    <span class="comment">//在 0 的位置对非 0 赋值</span></span><br><span class="line">    <span class="keyword">let</span> len = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> f = <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(s = <span class="number">0</span>; s &lt; len; s++)&#123;</span><br><span class="line">        <span class="keyword">while</span>( f &lt; len &amp;&amp; nums[f] == <span class="number">0</span>) f++;</span><br><span class="line">        <span class="keyword">if</span>(f &gt;= len) <span class="keyword">break</span>;</span><br><span class="line">        nums[s] = nums[f++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(s&lt;len)&#123;</span><br><span class="line">        nums[s++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="盛最多水的容器【双指针、贪心】"><a href="#盛最多水的容器【双指针、贪心】" class="headerlink" title="盛最多水的容器【双指针、贪心】"></a>盛最多水的容器【双指针、贪心】</h4><p><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></p><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= height[i] &lt;= 104</code></li></ul><p><strong>code</strong>：</p><p>前几天刚做过，复习了一下</p><p>双指针，两边夹</p><p>贪心的想法，由于装水的面积是右桶的长短决定的，所以较短的那条边先向中间走（这是保证从长到短的宽度下的最优解）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">height</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxArea = <span class="keyword">function</span>(<span class="params">height</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxNum = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> st = <span class="number">0</span>, end = height.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(st &lt; end)&#123;</span><br><span class="line">        maxNum = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxNum, (end - st) * <span class="title class_">Math</span>.<span class="title function_">min</span>(height[st], height[end]));</span><br><span class="line">        <span class="keyword">if</span>(height[st] &lt;= height[end])&#123;</span><br><span class="line">            st++;</span><br><span class="line">        &#125;<span class="keyword">else</span> end--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxNum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="【优先二刷】三数之和-【数组，双指针】"><a href="#【优先二刷】三数之和-【数组，双指针】" class="headerlink" title="【优先二刷】三数之和 【数组，双指针】"></a>【优先二刷】三数之和 【数组，双指针】</h4><p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></p><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。 </p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>code：</strong></p><p>排序去重是一个很重要的点，有很多题目，都是组成元素一样，但是顺序不一样，此时，应该考虑排序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> j = i; j &lt; nums.<span class="property">length</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( i != j)&#123;</span><br><span class="line">                <span class="keyword">let</span> sum = nums[i] + nums[j];</span><br><span class="line">                <span class="keyword">let</span> index = nums.<span class="title function_">indexOf</span>(-sum);</span><br><span class="line">                <span class="keyword">if</span>(index != -<span class="number">1</span> &amp;&amp; index != i &amp;&amp; index != j)&#123; </span><br><span class="line">                    <span class="keyword">let</span> arr = []; </span><br><span class="line">                    arr.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">                    arr.<span class="title function_">push</span>(nums[index]);</span><br><span class="line">                    arr.<span class="title function_">push</span>(nums[j]);              </span><br><span class="line">                    arr.<span class="title function_">sort</span>();</span><br><span class="line">                    <span class="keyword">if</span>(!set.<span class="title function_">has</span>(arr))&#123;</span><br><span class="line">                        res.<span class="title function_">push</span>(arr);</span><br><span class="line">                        set.<span class="title function_">add</span>(arr);</span><br><span class="line">                    &#125;     </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是这样写的话在JS中是不能用set去重的，因为set中的元素是对象，对象引用的是指针，就算排序后的数组中的每一个元素都是一样的，set也会认为这是不同的数组。然后尝试将数组使用join函数转换为字符串在传入set去重</p><p>但是还是有问题，测试用例过227&#x2F;313，不知道哪里错了，看不出来.</p><p>还有效率问题：您的代码使用了三层循环（实际上是两层循环加一个线性搜索 indexOf），这导致时间复杂度高达 O(n^3)，在 nums 数组较大时会非常低效。</p><p>思考：其实经常想不到sort排序的解法，应该想到的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> j = i; j &lt; nums.<span class="property">length</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( i != j)&#123;</span><br><span class="line">                <span class="keyword">let</span> sum = nums[i] + nums[j];</span><br><span class="line">                <span class="keyword">let</span> index = nums.<span class="title function_">indexOf</span>(-sum);</span><br><span class="line">                <span class="keyword">if</span>(index != -<span class="number">1</span> &amp;&amp; index != i &amp;&amp; index != j)&#123; </span><br><span class="line">                    <span class="keyword">let</span> arr = []; </span><br><span class="line">                    arr.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">                    arr.<span class="title function_">push</span>(nums[index]);</span><br><span class="line">                    arr.<span class="title function_">push</span>(nums[j]);              </span><br><span class="line">                    arr.<span class="title function_">sort</span>();</span><br><span class="line">                    <span class="keyword">let</span> str = arr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">                    <span class="keyword">if</span>(!set.<span class="title function_">has</span>(str))&#123;</span><br><span class="line">                        res.<span class="title function_">push</span>(arr);</span><br><span class="line">                        set.<span class="title function_">add</span>(str);</span><br><span class="line">                    &#125;     </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>转换思路，咨询了一下AI模型，跑了后还是对的</p><p>排序：首先对数组进行排序，这样可以更容易地避免重复的三元组，并且可以使用双指针技术来减少不必要的搜索。</p><p>双指针：使用一个外层循环遍历每个元素，然后在剩余部分使用两个指针（一个从左边开始，另一个从右边开始）来寻找两个数，使得这三个数的和为0。</p><p>跳过重复元素：在外层循环和双指针移动时，如果遇到相同的元素，应该跳过，以避免重复的三元组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="comment">//排序+循环嵌套双指针（两边夹）</span></span><br><span class="line">    <span class="comment">//因为有重复元素，还要去重</span></span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a - b);<span class="comment">//递增</span></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">2</span>; i++)&#123;<span class="comment">//-2时因为i是三元组的第一个，要构成三元组就不可能是最后一个</span></span><br><span class="line">        <span class="comment">//对于三元组中的第一个数，也要去重，同一个数，只操作一次</span></span><br><span class="line">        <span class="keyword">if</span>( i &gt; <span class="number">0</span>  &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//if( i + 1 &lt; nums.length - 2 &amp;&amp; nums[i + 1] == nums[i]) continue;这样的去重逻辑是错误的，不要这样写</span></span><br><span class="line">        <span class="comment">//双指针两边夹</span></span><br><span class="line">        <span class="keyword">let</span> left = i + <span class="number">1</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">let</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span>(sum === <span class="number">0</span>)&#123;<span class="comment">//找到一个三元组</span></span><br><span class="line">                res.<span class="title function_">push</span>([nums[i], nums[right], nums[left]]);</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="【！！dp，还没写】接雨水"><a href="#【！！dp，还没写】接雨水" class="headerlink" title="【！！dp，还没写】接雨水"></a>【！！dp，还没写】接雨水</h4><p><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></p><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [4,2,0,3,2,5]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h4 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h4><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><p><strong>code:</strong></p><p>不用map，用set和单纯数组都行，数组的话就用include方法来查看字母是否已经存在于数组中，但是最好还是不要数组了，数组里面删除一个元素会很麻烦，主要还是哈希+滑动窗口的思想。</p><p>用set的话会简单一点点</p><p>带注释版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//无重复字符的最长子串</span></span><br><span class="line">    <span class="comment">//ex</span></span><br><span class="line">    <span class="comment">// abcabcbb</span></span><br><span class="line">    <span class="comment">// abc -&gt; maxLen = 3</span></span><br><span class="line">    <span class="comment">//滑动窗口</span></span><br><span class="line">    <span class="comment">//1.定义需要维护的变量</span></span><br><span class="line">    <span class="keyword">let</span> maxLen = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> hash = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="comment">//2.定义窗口的首尾端，然后滑动窗口</span></span><br><span class="line">    <span class="keyword">let</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> end = <span class="number">0</span>; end &lt; s.<span class="property">length</span>; end++)&#123;<span class="comment">//第一次debug是end++写成s++了</span></span><br><span class="line">        <span class="comment">//维护变量</span></span><br><span class="line">        <span class="keyword">let</span> c = s[end];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//情况2:窗口可变,检查窗口是否合法，不合法就调整st指针直至合法  </span></span><br><span class="line">        <span class="comment">//在该题目中，不合法指的是，字符串中出现重复字符 </span></span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="title function_">has</span>(c))&#123;<span class="comment">//c字符不是第一次出现，窗口不合法</span></span><br><span class="line">            <span class="comment">//只要连续移动字符，直到新的窗口的字符中不包含第一次出现的c字符位置</span></span><br><span class="line">            <span class="keyword">while</span>( st &lt; end &amp;&amp; s[st] != c)&#123;</span><br><span class="line">                hash.<span class="title function_">delete</span>(s[st]);<span class="comment">//第二次debug，这一句和下面一句的顺序反了，如果先++在delet，那么相当于delet的是下一个字符，第一个字符永远都不会被移除</span></span><br><span class="line">                st++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//此时的st应该位于第一个窗口的第一个c字符处</span></span><br><span class="line">            st++;</span><br><span class="line">            <span class="comment">//现在窗口合法了</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//第一次出现</span></span><br><span class="line">            hash.<span class="title function_">set</span>(c, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//窗口的长度为end - st + 1 （左闭右闭区间）</span></span><br><span class="line">        <span class="comment">//如果是左闭右开区间，就是end - st</span></span><br><span class="line">        maxLen = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLen, end - st + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不带注释</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> maxLen = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> hash = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> end = <span class="number">0</span>; end &lt; s.<span class="property">length</span>; end++)&#123;</span><br><span class="line">        <span class="keyword">let</span> c = s[end];    </span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">            <span class="keyword">while</span>( st &lt; end &amp;&amp; s[st] != c)&#123;</span><br><span class="line">                hash.<span class="title function_">delete</span>(s[st]);</span><br><span class="line">                st++;</span><br><span class="line">            &#125; </span><br><span class="line">            st++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            hash.<span class="title function_">set</span>(c, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLen, end - st + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h4><p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></p><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span><br></pre></td></tr></table></figure><p> <strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;, p = &quot;ab&quot;</span><br><span class="line">输出: [0,1,2]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br></pre></td></tr></table></figure><p><strong>Code:</strong></p><p>窗口不合理的情况比较复杂</p><p>带注释版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">p</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findAnagrams = <span class="keyword">function</span>(<span class="params">s, p</span>) &#123;</span><br><span class="line">    <span class="comment">//哈希(异位词)+滑动窗口(子串)</span></span><br><span class="line">    <span class="comment">//异位词的特点是：</span></span><br><span class="line">    <span class="comment">//1.长度相等</span></span><br><span class="line">    <span class="comment">//2.每个字符的出现次数相等</span></span><br><span class="line">    <span class="keyword">let</span> hash = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> hash2 = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="comment">//初始化hash</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; p.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="title function_">has</span>(p[i]))&#123;</span><br><span class="line">            hash.<span class="title function_">set</span>(p[i], hash.<span class="title function_">get</span>(p[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> hash.<span class="title function_">set</span>(p[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化窗口，并开始滑动</span></span><br><span class="line">    <span class="keyword">let</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> end = <span class="number">0</span>; end &lt; s.<span class="property">length</span>; end++)&#123;</span><br><span class="line">        <span class="keyword">let</span> c = s[end];</span><br><span class="line">        <span class="keyword">if</span>(hash2.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">            hash2.<span class="title function_">set</span>(c, hash2.<span class="title function_">get</span>(c) + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> hash2.<span class="title function_">set</span>(c, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//窗口不合法1，没有这个字符,两个指针都跳到这个指针后面</span></span><br><span class="line">        <span class="keyword">if</span>(!hash.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">            <span class="keyword">while</span>(st != end + <span class="number">1</span>)&#123;<span class="comment">//debug1,一开始没有跳转到st = end+1，只是st++，这样是不对的，而且跳转完之后，一定要记得移除hash2中前面的（已经不在滑动窗口中的）字母</span></span><br><span class="line">                hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);</span><br><span class="line">                st++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(hash2.<span class="title function_">get</span>(c) &gt; hash.<span class="title function_">get</span>(c))&#123;</span><br><span class="line">            <span class="comment">//窗口不合法2,有这个字符，但是字符数多了,移动st，直到窗口中的c的字符数与hash中的字符数一致</span></span><br><span class="line">            <span class="keyword">while</span>(hash2.<span class="title function_">get</span>(c) != hash.<span class="title function_">get</span>(c))&#123;</span><br><span class="line">                hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);</span><br><span class="line">                st++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//窗口不合法3，窗口长度超过了</span></span><br><span class="line">        <span class="keyword">while</span>(end - st + <span class="number">1</span> &gt; p.<span class="property">length</span>)&#123;</span><br><span class="line">            hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);<span class="comment">//debug2，滑动了窗口，但是忘记处理hash2了</span></span><br><span class="line">            st++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(end - st + <span class="number">1</span> === p.<span class="property">length</span>)&#123;</span><br><span class="line">            res.<span class="title function_">push</span>(st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不带注释版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">p</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findAnagrams = <span class="keyword">function</span>(<span class="params">s, p</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> hash = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> hash2 = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; p.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="title function_">has</span>(p[i]))&#123;</span><br><span class="line">            hash.<span class="title function_">set</span>(p[i], hash.<span class="title function_">get</span>(p[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> hash.<span class="title function_">set</span>(p[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> end = <span class="number">0</span>; end &lt; s.<span class="property">length</span>; end++)&#123;</span><br><span class="line">        <span class="keyword">let</span> c = s[end];</span><br><span class="line">        <span class="keyword">if</span>(hash2.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">            hash2.<span class="title function_">set</span>(c, hash2.<span class="title function_">get</span>(c) + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> hash2.<span class="title function_">set</span>(c, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!hash.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">            <span class="keyword">while</span>(st != end + <span class="number">1</span>)&#123;</span><br><span class="line">                hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);</span><br><span class="line">                st++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(hash2.<span class="title function_">get</span>(c) &gt; hash.<span class="title function_">get</span>(c))&#123;</span><br><span class="line">            <span class="keyword">while</span>(hash2.<span class="title function_">get</span>(c) != hash.<span class="title function_">get</span>(c))&#123;</span><br><span class="line">                hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);</span><br><span class="line">                st++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(end - st + <span class="number">1</span> &gt; p.<span class="property">length</span>)&#123;</span><br><span class="line">            hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);</span><br><span class="line">            st++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(end - st + <span class="number">1</span> === p.<span class="property">length</span>)&#123;</span><br><span class="line">            res.<span class="title function_">push</span>(st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><h4 id="【优先二刷】和为-K-的子数组"><a href="#【优先二刷】和为-K-的子数组" class="headerlink" title="【优先二刷】和为 K 的子数组"></a>【优先二刷】和为 K 的子数组</h4><p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p><p>子数组是数组中元素的连续非空序列。 </p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1], k = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3], k = 3</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>code:</strong></p><p>一刷本来想用滑动窗口做，但是发现有负数，没法用滑动窗口做。</p><p>这个问题可以通过使用“前缀和”加上“哈希表”来高效解决。基本思路是，我们遍历数组，计算每个位置的前缀和，即从数组开始到当前元素的累计和。然后，对于每个前缀和，我们检查是否存在一个之前的前缀和，其值等于“当前前缀和 - k”。如果存在，这意味着这两个前缀和之间的元素的和正好为k。我们使用哈希表来存储每个前缀和出现的次数，这样就可以在O(1)时间内查找到之前的前缀和。</p><p>在这道题学会了<code>前缀和</code>的用法，这确实是我比较少用的一个点</p><p>学习了：</p><ul><li><p>前缀和的思想</p></li><li><p>用对象来构建哈希表</p></li><li><p>let of的用法，</p><ul><li><p>let of访问的是value</p></li><li><p>let in访问的是索引号</p></li><li><p>如果想同时访问value和index可以用for循环或者<code>nums.forEach((value, index) =&gt; &#123;console.log(1);&#125;);</code></p></li></ul></li></ul><blockquote><p><code>forEach()</code>方法在遍历数组时访问的是原数组。这意味着在<code>forEach()</code>循环中，您可以直接访问并操作原数组的元素。</p><p><code>forEach()</code>里面的回调函数确实可以修改原数组的元素。但是，需要注意的是，虽然您可以修改数组的元素，比如通过索引更改元素的值，您却不能通过<code>forEach()</code>直接修改数组的结构，例如增加或删除元素，对数组结构的修改不会影响到遍历过程。这是因为<code>forEach()</code>遍历的范围在第一次调用回调函数之前就已经确定了。</p><p>下面是一个示例，展示了如何通过<code>forEach()</code>修改原数组的元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 forEach() 修改数组元素的值</span></span><br><span class="line">nums.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 将每个元素值加倍</span></span><br><span class="line">    array[index] = value * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nums); <span class="comment">// 输出: [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们通过<code>forEach()</code>遍历数组，并将每个元素的值加倍。虽然我们在<code>forEach()</code>的回调函数中直接修改了数组元素的值，但是请注意，如果尝试在遍历过程中添加或删除元素，可能不会影响当前的遍历过程，因为遍历的范围是在遍历开始前就已经确定了。</p></blockquote><p>由此可见，这是一个数学题TAT，思路如下：</p><p>a1 a2 a3 a4 a5 a6<br>cn1 &#x3D; a1 + a2<br>cn2 &#x3D; a1 + a2 + a3 + a4</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//如果 a3 + a4 = k =&gt;有一个子串和位k</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> subarraySum = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pre_sum_hash = &#123;<span class="number">0</span> : <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> num <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        sum += num;</span><br><span class="line">        <span class="comment">// sum - otherPreSum = k =&gt; sum - k = otherPreSum </span></span><br><span class="line">        <span class="keyword">let</span> otherPreSum = sum - k;</span><br><span class="line">        <span class="keyword">if</span>(pre_sum_hash[otherPreSum] !== <span class="literal">undefined</span>)&#123;</span><br><span class="line">            res += pre_sum_hash[otherPreSum];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新哈希表</span></span><br><span class="line">        <span class="keyword">if</span>(pre_sum_hash[sum] !== <span class="literal">undefined</span>)&#123;</span><br><span class="line">            pre_sum_hash[sum]++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre_sum_hash[sum] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="http://shiff.top/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      <category domain="http://shiff.top/tags/JavaScript/">JavaScript</category>
      
      <category domain="http://shiff.top/tags/leetcod/">leetcod</category>
      
      
      <comments>http://shiff.top/2024/05/12/leetcode%E7%83%AD%E9%A2%98hot100/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>《JavaScript权威指南》读书笔记第七章函数表达式</title>
      <link>http://shiff.top/2024/05/11/%E3%80%8AjavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <guid>http://shiff.top/2024/05/11/%E3%80%8AjavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <pubDate>Sat, 11 May 2024 09:47:12 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;第七章——函数表达式&quot;&gt;&lt;a href=&quot;#第七章——函数表达式&quot; class=&quot;headerlink&quot; title=&quot;第七章——函数表达式&quot;&gt;&lt;/a&gt;第七章——函数表达式&lt;/h1&gt;&lt;h2 id=&quot;函数表达式的特征&quot;&gt;&lt;a href=&quot;#函数表达式的特征&quot; cla</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="第七章——函数表达式"><a href="#第七章——函数表达式" class="headerlink" title="第七章——函数表达式"></a>第七章——函数表达式</h1><h2 id="函数表达式的特征"><a href="#函数表达式的特征" class="headerlink" title="函数表达式的特征"></a>函数表达式的特征</h2><p>定义函数的两种方法：</p><ul><li><p>函数声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params">arg0, arg1, arg2</span>)&#123;</span><br><span class="line">  <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有一些浏览器给函数定义了一个name属性，可以通过这个属性访问到给函数指定的名字，这个值为function关键字后面的标识符。</p><p>alert(function.name);&#x2F;&#x2F;“funtionName”</p></blockquote></li><li><p>函数表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>两个定义函数的方法的异同：</p><p>由函数声明的函数在JS脚本构建时，会<code>函数提升</code>，而由函数表达式定义的函数不会。</p><h2 id="使用函数实现递归"><a href="#使用函数实现递归" class="headerlink" title="使用函数实现递归"></a>使用函数实现递归</h2><h2 id="使用闭包定义私有变量"><a href="#使用闭包定义私有变量" class="headerlink" title="使用闭包定义私有变量"></a>使用闭包定义私有变量</h2>]]></content:encoded>
      
      
      
      <category domain="http://shiff.top/tags/JavaScript/">JavaScript</category>
      
      <category domain="http://shiff.top/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</category>
      
      
      <comments>http://shiff.top/2024/05/11/%E3%80%8AjavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>双指针：两个输入,两个都需要遍历（快慢指针）</title>
      <link>http://shiff.top/2024/05/10/%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%9A%E4%B8%A4%E4%B8%AA%E8%BE%93%E5%85%A5-%E4%B8%A4%E4%B8%AA%E9%83%BD%E9%9C%80%E8%A6%81%E9%81%8D%E5%8E%86%EF%BC%88%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%EF%BC%89/</link>
      <guid>http://shiff.top/2024/05/10/%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%9A%E4%B8%A4%E4%B8%AA%E8%BE%93%E5%85%A5-%E4%B8%A4%E4%B8%AA%E9%83%BD%E9%9C%80%E8%A6%81%E9%81%8D%E5%8E%86%EF%BC%88%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%EF%BC%89/</guid>
      <pubDate>Fri, 10 May 2024 08:41:08 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;2-双指针：两个输入-两个都需要遍历（快慢指针）&quot;&gt;&lt;a href=&quot;#2-双指针：两个输入-两个都需要遍历（快慢指针）&quot; class=&quot;headerlink&quot; title=&quot;2.双指针：两个输入,两个都需要遍历（快慢指针）&quot;&gt;&lt;/a&gt;2.双指针：两个输入,两个都</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="2-双指针：两个输入-两个都需要遍历（快慢指针）"><a href="#2-双指针：两个输入-两个都需要遍历（快慢指针）" class="headerlink" title="2.双指针：两个输入,两个都需要遍历（快慢指针）"></a>2.双指针：两个输入,两个都需要遍历（快慢指针）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params">arr1, arr2</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(i &lt; arr1.<span class="property">length</span> &amp;&amp; j &lt; arr2.<span class="property">length</span>)&#123;</span><br><span class="line">    <span class="comment">//根据题意补充代码</span></span><br><span class="line">    <span class="keyword">if</span>()&#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; arr1.<span class="property">length</span>)&#123;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; arr2.<span class="property">length</span>)&#123;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><a href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组</a></p><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p><p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p><p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br><span class="line">解释：需要合并 [1,2,3] 和 [2,5,6] 。</span><br><span class="line">合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1], m = 1, nums2 = [], n = 0</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并 [1] 和 [] 。</span><br><span class="line">合并结果是 [1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [0], m = 0, nums2 = [1], n = 1</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并的数组是 [] 和 [1] 。</span><br><span class="line">合并结果是 [1] 。</span><br><span class="line">注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</span><br></pre></td></tr></table></figure><p>思路一：双指针，但是不借助额外的数组，原数组nums1的值就会被覆盖，但是题目没有说不能借助额外数组，所以就先放到新的数组里面，在把新数组赋值给nuns1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">m</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//思路一：双指针，但是不借助额外的数组，原数组nums1的值就会被覆盖，但是题目没有说不能借助额外数组，所以就先放到新的数组里面，在把新数组赋值给nuns1</span></span><br><span class="line">    <span class="keyword">let</span> newArr = <span class="keyword">new</span> <span class="title class_">Array</span>(m + n);</span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; m &amp;&amp; j &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums2[j] &lt;= nums1[i])&#123;</span><br><span class="line">            newArr[k++] = nums2[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            newArr[k++] = nums1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; m) newArr[k++] = nums1[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n) newArr[k++] = nums2[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> p = <span class="number">0</span>; p &lt; m + n; p++)&#123;</span><br><span class="line">        nums1[p] = newArr[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路二：逆向双指针，因为num1的数组的末尾m个都是0，是不害怕被覆盖的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">m</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>, k = m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[i] &gt;= nums2[j])&#123;</span><br><span class="line">            nums1[k--] = nums1[i--];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            nums1[k--] = nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span>) nums1[k--] = nums1[i--];</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span>) nums1[k--] = nums2[j--];</span><br><span class="line">    <span class="keyword">return</span> nums1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="http://shiff.top/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      <category domain="http://shiff.top/tags/JavaScript/">JavaScript</category>
      
      
      <comments>http://shiff.top/2024/05/10/%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%9A%E4%B8%A4%E4%B8%AA%E8%BE%93%E5%85%A5-%E4%B8%A4%E4%B8%AA%E9%83%BD%E9%9C%80%E8%A6%81%E9%81%8D%E5%8E%86%EF%BC%88%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>双指针：一个输入，两端遍历（两边夹）</title>
      <link>http://shiff.top/2024/05/10/%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%9A%E4%B8%80%E4%B8%AA%E8%BE%93%E5%85%A5%EF%BC%8C%E4%B8%A4%E7%AB%AF%E9%81%8D%E5%8E%86%EF%BC%88%E4%B8%A4%E8%BE%B9%E5%A4%B9%EF%BC%89/</link>
      <guid>http://shiff.top/2024/05/10/%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%9A%E4%B8%80%E4%B8%AA%E8%BE%93%E5%85%A5%EF%BC%8C%E4%B8%A4%E7%AB%AF%E9%81%8D%E5%8E%86%EF%BC%88%E4%B8%A4%E8%BE%B9%E5%A4%B9%EF%BC%89/</guid>
      <pubDate>Fri, 10 May 2024 08:04:21 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;双指针：一个输入，两端遍历（两边夹）&quot;&gt;&lt;a href=&quot;#双指针：一个输入，两端遍历（两边夹）&quot; class=&quot;headerlink&quot; title=&quot;双指针：一个输入，两端遍历（两边夹）&quot;&gt;&lt;/a&gt;双指针：一个输入，两端遍历（两边夹）&lt;/h3&gt;&lt;figure c</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="双指针：一个输入，两端遍历（两边夹）"><a href="#双指针：一个输入，两端遍历（两边夹）" class="headerlink" title="双指针：一个输入，两端遍历（两边夹）"></a>双指针：一个输入，两端遍历（两边夹）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//箭头函数 ()=&gt;&#123;&#125;</span></span><br><span class="line"><span class="comment">//()表示参数</span></span><br><span class="line"><span class="comment">//&#123;&#125;表示函数体</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">fn</span> = arr =&gt;&#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>, ans = <span class="number">0</span>, right = arr.<span class="property">length</span> -<span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="comment">//根据题意补充代码</span></span><br><span class="line">    <span class="keyword">if</span>()&#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></p><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1 </span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= height[i] &lt;= 104</code></li></ul><p>做题思路：</p><p>双指针</p><p>长*宽的最大值，迭代</p><p>难点在于在什么情况下移动左指针，在什么情况下移动右指针</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">height</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxArea = <span class="keyword">function</span>(<span class="params">height</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = height.<span class="property">length</span> - <span class="number">1</span>, maxAns = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">let</span> w = right - left;</span><br><span class="line">        <span class="keyword">let</span> h = <span class="title class_">Math</span>.<span class="title function_">min</span>(height[left], height[right]);</span><br><span class="line">        maxAns = <span class="title class_">Math</span>.<span class="title function_">max</span>(w * h, maxAns);</span><br><span class="line">        <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxAns</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考官方题解</p><p><a href="https://leetcode.cn/problems/container-with-most-water/solutions/207215/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution">https://leetcode.cn/problems/container-with-most-water/solutions/207215/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution</a></p>]]></content:encoded>
      
      
      
      <category domain="http://shiff.top/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      <category domain="http://shiff.top/tags/JavaScript/">JavaScript</category>
      
      
      <comments>http://shiff.top/2024/05/10/%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%9A%E4%B8%80%E4%B8%AA%E8%BE%93%E5%85%A5%EF%BC%8C%E4%B8%A4%E7%AB%AF%E9%81%8D%E5%8E%86%EF%BC%88%E4%B8%A4%E8%BE%B9%E5%A4%B9%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>【Vue】v-bind</title>
      <link>http://shiff.top/2024/04/24/%E3%80%90Vue%E3%80%91v-bind/</link>
      <guid>http://shiff.top/2024/04/24/%E3%80%90Vue%E3%80%91v-bind/</guid>
      <pubDate>Wed, 24 Apr 2024 08:47:31 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;v-bind&quot;&gt;&lt;a href=&quot;#v-bind&quot; class=&quot;headerlink&quot; title=&quot;v-bind&quot;&gt;&lt;/a&gt;v-bind&lt;/h1&gt;&lt;p&gt; 是Vue.js中的一个指令，用于动态地绑定一个或多个属性，或者传递属性到组件。它可以将数据的值绑定到HTM</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h1><p> 是Vue.js中的一个指令，用于动态地绑定一个或多个属性，或者传递属性到组件。它可以将数据的值绑定到HTML元素的属性上，或者是父组件向子组件传递数据。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li><strong>绑定HTML属性</strong>：可以将数据绑定到元素的属性上。例如，如果你想根据数据动态改变<img>的src属性，可以这样写：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img v-<span class="attr">bind</span>:src=<span class="string">&quot;imageSrc&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>这里，imageSrc是一个变量名，它的值会被设置为img的src属性。</p><ul><li><strong>缩写</strong>：v-bind:有一个缩写，即冒号:。上面的例子可以简写为：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img :src=<span class="string">&quot;imageSrc&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="绑定多个属性"><a href="#绑定多个属性" class="headerlink" title="绑定多个属性"></a>绑定多个属性</h3><p>v-bind也可以通过使用对象语法一次绑定多个属性。例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind=<span class="string">&quot;&#123; id: someId, &#x27;data-name&#x27;: name &#125;&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这里，someId和name是变量，它们的值将分别绑定到div的id属性和data-name属性。</p><h3 id="绑定到组件的props"><a href="#绑定到组件的props" class="headerlink" title="绑定到组件的props"></a>绑定到组件的props</h3><p>当使用组件时，v-bind用于将数据从父组件传递到子组件的props：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component :some-prop=<span class="string">&quot;someData&quot;</span>&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure><p>这里，someData是父组件中的数据，some-prop是子组件的prop，someData的值将传递给子组件的some-prop。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>动态绑定元素的类和样式。</p><p>将数据传递给组件的props。</p><p>根据数据动态改变元素的属性，如src、href等。</p><p>v-bind:是Vue开发中非常常用的一个指令，它提高了代码的灵活性和可维护性，使得数据和视图之间的绑定更加直观和方便。</p><blockquote><p>V-bind可以绑定变量、绑定类、绑定属性等等</p></blockquote>]]></content:encoded>
      
      
      
      <category domain="http://shiff.top/tags/Vue3/">Vue3</category>
      
      <category domain="http://shiff.top/tags/Vue2/">Vue2</category>
      
      
      <comments>http://shiff.top/2024/04/24/%E3%80%90Vue%E3%80%91v-bind/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>鉴权失败</title>
      <link>http://shiff.top/2024/04/24/%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5/</link>
      <guid>http://shiff.top/2024/04/24/%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5/</guid>
      <pubDate>Wed, 24 Apr 2024 08:35:46 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;【git部署时输入密码错误】remote-Support-for-password-authentication-was-removed-on-August-13-2021-remote-Please-see-https-docs-github-com-get-s</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="【git部署时输入密码错误】remote-Support-for-password-authentication-was-removed-on-August-13-2021-remote-Please-see-https-docs-github-com-get-started-getting-started-with-git-about-remote-repositories-cloning-with-https-urls-for-information-on-currently-recommended-modes-of-authentication-致命错误：’https-github-com-SHIFFF-SHIFFF-github-io-git-‘-鉴权失败"><a href="#【git部署时输入密码错误】remote-Support-for-password-authentication-was-removed-on-August-13-2021-remote-Please-see-https-docs-github-com-get-started-getting-started-with-git-about-remote-repositories-cloning-with-https-urls-for-information-on-currently-recommended-modes-of-authentication-致命错误：’https-github-com-SHIFFF-SHIFFF-github-io-git-‘-鉴权失败" class="headerlink" title="【git部署时输入密码错误】remote: Support for password authentication was removed on August 13, 2021. remote: Please see https://docs.github.com/get-started/getting-started-with-git/about-remote-repositories#cloning-with-https-urls for information on currently recommended modes of authentication. 致命错误：’https://github.com/SHIFFF/SHIFFF.github.io.git/‘ 鉴权失败"></a>【git部署时输入密码错误】remote: Support for password authentication was removed on August 13, 2021. remote: Please see <a href="https://docs.github.com/get-started/getting-started-with-git/about-remote-repositories#cloning-with-https-urls">https://docs.github.com/get-started/getting-started-with-git/about-remote-repositories#cloning-with-https-urls</a> for information on currently recommended modes of authentication. 致命错误：’<a href="https://github.com/SHIFFF/SHIFFF.github.io.git/">https://github.com/SHIFFF/SHIFFF.github.io.git/</a>‘ 鉴权失败</h3><p>GitHub于2021年8月13日移除了对密码身份验证的支持，因此您需要使用其他身份验证方式来访问GitHub仓库。</p><p>推荐的替代方式是使用个人访问令牌（Personal Access Token）作为身份验证凭据。您可以在GitHub上生成一个个人访问令牌，并将其用作密码来访问您的仓库。</p><p>以下是解决此问题的一般步骤：</p><ol><li><p>在GitHub上生成个人访问令牌：</p><ul><li>登录GitHub账号，转到Settings -&gt; Developer settings -&gt; Personal access tokens。</li><li>点击Generate new token，选择所需的权限，并生成访问令牌。</li><li>复制生成的访问令牌。</li></ul></li><li><p>在Git中使用个人访问令牌：</p><ul><li>当Git提示输入用户名和密码时，用户名为您的GitHub用户名，密码为您生成的个人访问令牌。</li></ul></li></ol><p>通过这种方式，您应该能够成功进行身份验证并访问您的GitHub仓库。如果问题仍然存在，请参考提供的链接以获取更多信息或尝试其他解决方案。</p>]]></content:encoded>
      
      
      
      <category domain="http://shiff.top/tags/git/">git</category>
      
      <category domain="http://shiff.top/tags/error/">error</category>
      
      
      <comments>http://shiff.top/2024/04/24/%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>【Vue3】withDefaults和defineProps</title>
      <link>http://shiff.top/2024/04/24/%E3%80%90Vue3%E3%80%91withDefaults%E5%92%8CdefineProps/</link>
      <guid>http://shiff.top/2024/04/24/%E3%80%90Vue3%E3%80%91withDefaults%E5%92%8CdefineProps/</guid>
      <pubDate>Wed, 24 Apr 2024 07:47:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;在Vue 3中，withDefaults和defineProps是用于定义和设置组件的props的工具，特别是在使用script setup语法糖时。&lt;/p&gt;
&lt;h3 id=&quot;defineProps&quot;&gt;&lt;a href=&quot;#defineProps&quot; class=&quot;header</description>
        
      
      
      
      <content:encoded><![CDATA[<p>在Vue 3中，withDefaults和defineProps是用于定义和设置组件的props的工具，特别是在使用script setup语法糖时。</p><h3 id="defineProps"><a href="#defineProps" class="headerlink" title="defineProps"></a>defineProps</h3><p>defineProps函数用于在Vue组件中声明props的类型。它通常与TypeScript一起使用，以提供类型安全。在script setup语法中，defineProps用于定义接收自父组件的数据的属性。</p><h3 id="withDefaults"><a href="#withDefaults" class="headerlink" title="withDefaults"></a>withDefaults</h3><p>withDefaults函数在Vue 3中用于为defineProps定义的props提供默认值。它的参数结构如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">withDefaults</span>(defineProps&lt;<span class="title class_">Type</span>&gt;(), defaultProps)</span><br></pre></td></tr></table></figure><ul><li><p>第一个参数是defineProps调用的结果，defineProps<Type>()用于定义组件的props，并且可以指定一个TypeScript接口或类型来静态类型检查这些props。</p></li><li><p>第二个参数是一个对象，其中的键是prop的名字，值是这个prop的默认值。默认值可以是直接的值，或者是返回值的函数，这样每次使用默认值时都会调用该函数来获取一个新的值。</p></li></ul><p>例如</p><p>withDefaults函数用于为defineProps定义的props提供默认值。这是处理props可能未被父组件传递时的情况的一种方式，确保组件有一个可靠的默认状态。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineProps, withDefaults &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">  <span class="attr">postList</span>: <span class="built_in">any</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> props = <span class="title function_">withDefaults</span>(defineProps&lt;<span class="title class_">Props</span>&gt;(),&#123;</span><br><span class="line">  <span class="attr">postList</span>: <span class="function">() =&gt;</span> [],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>defineProps<Props>()：这里使用Props接口来定义props的结构，Props接口指定了postList是一个数组。</p></li><li><p>withDefaults(…, { postList: () &#x3D;&gt; [] })：这里为postList提供了一个默认值。默认值是通过一个函数() &#x3D;&gt; []来指定的，这意味着如果没有提供postList，它将默认为一个空数组。使用函数来返回默认值是一种常见的做法，因为这确保了每次使用默认值时都会创建一个新的数组实例，避免了不同实例间共享同一个数组的问题。</p></li></ul><h3 id="postList-x3D-gt-的意思"><a href="#postList-x3D-gt-的意思" class="headerlink" title="postList: () &#x3D;&gt; []的意思"></a>postList: () &#x3D;&gt; []的意思</h3><p>这里postList: () &#x3D;&gt; []表示postList的默认值是一个空数组。使用箭头函数()返回一个新的空数组[]，这样做的好处是每次调用这个默认值时都会创建一个新的数组实例，避免了潜在的引用类型数据共享问题，这是在JavaScript中处理数组和对象默认值的推荐做法。</p><p>总结来说，这种写法确保了组件的postList prop在没有从父组件接收到值时，会安全地使用一个新的空数组作为默认值，同时保持了类型安全和响应性。</p>]]></content:encoded>
      
      
      
      <category domain="http://shiff.top/tags/Vue3/">Vue3</category>
      
      <category domain="http://shiff.top/tags/TypeScript/">TypeScript</category>
      
      
      <comments>http://shiff.top/2024/04/24/%E3%80%90Vue3%E3%80%91withDefaults%E5%92%8CdefineProps/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
