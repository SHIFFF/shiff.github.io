<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Flex布局与Grid布局</title>
    <url>/2024/06/17/Flex%E5%B8%83%E5%B1%80%E4%B8%8EGrid%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="Flex布局与Grid布局"><a href="#Flex布局与Grid布局" class="headerlink" title="Flex布局与Grid布局"></a>Flex布局与Grid布局</h1><p>Grid布局和Flex布局都是在CSS中用于进行页面布局的工具，它们各有优势和适用场景。以下是它们的一些异同点以及优缺点：</p>
<p><strong>异同点：</strong></p>
<ol>
<li><p><strong>相同点：</strong></p>
<ul>
<li>两者都是现代CSS布局工具，用于实现响应式布局和页面排版。</li>
<li>都支持对网格和弹性盒子进行灵活布局。</li>
<li>都可以在容器内部的子元素之间创建空间布局。</li>
</ul>
</li>
<li><p><strong>不同点：</strong></p>
<ul>
<li><p><strong>Flex布局（弹性布局）：</strong></p>
<ul>
<li>适用于一维布局，例如在一条水平或垂直的轴线上布局元素。</li>
<li>适合于构建灵活的、水平或垂直居中的布局。</li>
<li>可以根据内容的大小来调整元素的尺寸。</li>
</ul>
</li>
<li><p><strong>Grid布局（网格布局）：</strong></p>
<ul>
<li>适用于二维布局，可以在交叉轴上对元素进行定位，创建复杂的网格布局。</li>
<li>适用于规划复杂的网格结构，如页面布局的整体设计。</li>
<li>可以控制行与列交叉点的位置，实现更精确的布局设计。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>优缺点：</strong></p>
<ol>
<li><p><strong>Flex布局优点：</strong></p>
<ul>
<li>简单实用，适合搭建基本的布局和页面结构。</li>
<li>支持响应式布局，更容易实现移动端适配，适合移动端开发。</li>
<li>配合弹性盒子布局的属性丰富，可以快速实现元素的排列和对齐。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>适用于相对简单布局，复杂的网格结构可能实现起来比较困难。</li>
<li>不太适合搭建复杂的多列布局。</li>
</ul>
</li>
<li><p><strong>Grid布局优点：</strong></p>
<ul>
<li>可以实现更复杂的网格布局，可以精确控制元素的位置和大小。</li>
<li>适合搭建大型网站和复杂的设计布局。</li>
<li>支持分区和定位，可以创建更灵活的页面结构。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>学习成本相对较高，语法相对复杂，初学者可能需要一定时间适应。</li>
<li>在一维布局方面不如Flex布局灵活，并不适用于所有布局场景。</li>
</ul>
</li>
</ol>
<p><strong>结论：</strong> </p>
<ul>
<li>如果页面结构相对简单，主要涉及到一维布局的元素排列和对齐，Flex布局是一个不错的选择。</li>
<li>如果需要实现复杂的二维布局，例如创建大型网格结构，Grid布局更适合用来实现。</li>
<li>在实际项目中，可以根据具体需求和布局复杂度来选择合适的布局方法，有时候也可以结合使用两者来实现更灵活和多样化的布局效果。</li>
</ul>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>文本的截断和显示控制</title>
    <url>/2024/06/16/%E6%96%87%E6%9C%AC%E7%9A%84%E6%88%AA%E6%96%AD%E5%92%8C%E6%98%BE%E7%A4%BA%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="文本的截断和显示控制"><a href="#文本的截断和显示控制" class="headerlink" title="文本的截断和显示控制"></a>文本的截断和显示控制</h1><p>下面三个属性通常用于在Web开发中对文本进行截断和显示控制，主要用于控制文本在容器中的显示方式。具体含义如下：</p>
<ol>
<li><p><code>display: -webkit-box;</code>：这个属性用于指定元素应该生成一个块级容器框。在这种布局模型中，元素是一个块级容器，可以在内部容纳其他元素。在这种情况下，通常需要与其他属性结合使用。</p>
</li>
<li><p><code>-webkit-line-clamp: 2;</code>：这个属性用于指定显示的行数限制。在文本溢出时，只显示指定行数的文本内容。上面的例子中，只显示不超过两行的文本内容。</p>
</li>
<li><p><code> -webkit-box-orient: vertical;</code>：这个属性用于指定盒子的排列方向。在这种情况下，盒子内的元素垂直排列。</p>
</li>
</ol>
<p>这些属性通常与前缀 <code>-webkit-</code> 一起使用，表示这些属性是Webkit浏览器专有的CSS扩展。这些属性主要用于控制元素的显示方式，特别是在限制文本显示行数和盒子内元素排列方向方面。</p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>text-overflow的用法</title>
    <url>/2024/06/14/text-overflow%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="text-overflow的用法"><a href="#text-overflow的用法" class="headerlink" title="text-overflow的用法"></a>text-overflow的用法</h1><p><code>text-overflow</code>是CSS样式属性，用于控制当文本溢出容器时如何显示。</p>
<p>常见的取值有：</p>
<ul>
<li><code>clip</code>：默认值，表示将溢出的部分隐藏。</li>
<li><code>ellipsis</code>：表示将溢出的文本显示为省略号（…）。</li>
<li><code>inherit</code>：继承父元素的文本溢出样式。</li>
</ul>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.text-ellipsis</span> &#123;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap; <span class="comment">/* 不换行 */</span></span><br><span class="line">  <span class="attribute">overflow</span>: hidden; <span class="comment">/* 溢出隐藏 */</span></span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis; <span class="comment">/* 超出部分以省略号显示 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，当文本内容超出容器的宽度时，将以省略号的形式显示。需要注意的是，通常需要配合<code>white-space: nowrap;</code>和<code>overflow: hidden;</code>这两个样式属性一起使用，来确保省略号的效果正常显示。</p>
<p><code>text-overflow</code>通常用于单行文本或者内联元素，对于多行文本或块级元素，更适合使用<code>-webkit-line-clamp</code>结合<code>-webkit-box</code>来实现类似的效果。</p>
]]></content>
  </entry>
  <entry>
    <title>less中的&amp;符号</title>
    <url>/2024/06/14/less%E4%B8%AD%E7%9A%84&amp;%E7%AC%A6%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="less中的-amp-符号"><a href="#less中的-amp-符号" class="headerlink" title="less中的&amp;符号"></a>less中的&amp;符号</h1><p>在 Less 预处理器中，<code>&amp;</code> 符号用于引用当前选择器的父级。这在嵌套规则中非常有用，可以帮助生成更复杂的选择器，而不需要重复父选择器的名称。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>在 Less 中，<code>&amp;</code> 符号代表父选择器，可以用来构建更复杂的选择器规则。例如：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">        <span class="attribute">content</span>: <span class="string">&quot;Prefix&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后的 CSS 如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;Prefix&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h3><p>以下是一些常见的 <code>&amp;</code> 符号用法示例：</p>
<h4 id="1-伪类和伪元素"><a href="#1-伪类和伪元素" class="headerlink" title="1. 伪类和伪元素"></a>1. 伪类和伪元素</h4><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: darkgreen;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">        <span class="attribute">content</span>: <span class="string">&quot; (hover me)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后的 CSS：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: darkgreen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.button</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot; (hover me)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-子选择器"><a href="#2-子选择器" class="headerlink" title="2. 子选择器"></a>2. 子选择器</h4><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.nav</span> &#123;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-tag">-item</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后的 CSS：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.nav-item</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-父选择器引用"><a href="#3-父选择器引用" class="headerlink" title="3. 父选择器引用"></a>3. 父选择器引用</h4><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list</span> &#123;</span><br><span class="line">    <span class="selector-class">.list-item</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">        </span><br><span class="line">        <span class="selector-tag">&amp;</span><span class="selector-class">.active</span> &#123;</span><br><span class="line">            <span class="attribute">color</span>: darkblue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后的 CSS：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list</span> <span class="selector-class">.list-item</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list</span> <span class="selector-class">.list-item</span><span class="selector-class">.active</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: darkblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-嵌套媒体查询"><a href="#4-嵌套媒体查询" class="headerlink" title="4. 嵌套媒体查询"></a>4. 嵌套媒体查询</h4><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">        <span class="selector-tag">&amp;</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后的 CSS：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.container</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>&amp;</code> 符号在 Less 中非常强大，可以帮助你避免重复代码，并使样式表更具可读性和可维护性。通过合理使用 <code>&amp;</code> 符号，可以轻松创建复杂的选择器规则，提升 CSS 编写的效率和灵活性。</p>
]]></content>
      <tags>
        <tag>Less</tag>
      </tags>
  </entry>
  <entry>
    <title>flex-shrink的用法</title>
    <url>/2024/06/14/flex-shrink%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="flex-shrink的用法"><a href="#flex-shrink的用法" class="headerlink" title="flex-shrink的用法"></a>flex-shrink的用法</h1><p><code>flex-shrink</code> 是 CSS Flexbox 布局模块中的一个属性，用于指定一个 flex 项目在容器空间不足时如何缩小。它定义了 flex 项目相对于其他 flex 项目的缩小比例。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex-shrink</span>: &lt;number&gt;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;number&gt;</code>：一个非负数，表示缩小比例。默认值是 1。</li>
</ul>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><code>flex-shrink</code> 属性的值越大，元素在空间不足时缩小得越多。相对值为 0 的元素不会缩小。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设有一个包含三个子元素的容器：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item1&quot;</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item2&quot;</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item3&quot;</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS 代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item1</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">1</span>; <span class="comment">/* 默认值 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item2</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item3</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">0</span>; <span class="comment">/* 不会缩小 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>item1</code> 的 <code>flex-shrink</code> 值是 1，表示它会按默认比例缩小。</li>
<li><code>item2</code> 的 <code>flex-shrink</code> 值是 2，表示它会以两倍于 <code>item1</code> 的比例缩小。</li>
<li><code>item3</code> 的 <code>flex-shrink</code> 值是 0，表示它不会缩小。</li>
</ul>
<p>当容器的宽度不足以容纳所有子元素的宽度时，<code>item1</code> 和 <code>item2</code> 会缩小，而 <code>item3</code> 保持原始宽度。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>flex-shrink</code> 属性只在容器的宽度不足以容纳所有 flex 项目时起作用。</li>
<li>如果所有的 <code>flex-shrink</code> 值都设置为 0，则所有项目都不会缩小。</li>
</ul>
<p>通过合理设置 <code>flex-shrink</code> 值，可以更好地控制页面布局在不同屏幕尺寸下的表现。</p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>overflow的用法</title>
    <url>/2024/06/14/overflow%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Overflow的用法"><a href="#Overflow的用法" class="headerlink" title="Overflow的用法"></a>Overflow的用法</h1><p><code>overflow</code> 是 CSS 中的一个属性，用于控制元素内容在水平方向和垂直方向上的溢出行为。它决定了当内容溢出元素的尺寸时，是否显示滚动条、截断内容或其他处理方式。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: visible | hidden | scroll | auto;</span><br></pre></td></tr></table></figure>

<h3 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h3><ul>
<li><code>visible</code>：默认值。内容不会被剪裁，会呈现在元素框之外。</li>
<li><code>hidden</code>：溢出内容会被剪裁（隐藏），不会显示滚动条。</li>
<li><code>scroll</code>：无论内容是否溢出，都会显示滚动条。</li>
<li><code>auto</code>：如果内容溢出，浏览器会自动显示滚动条。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设有一个包含大量文本的容器：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse varius enim in eros elementum tristique.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS 代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">overflow</span>: auto; <span class="comment">/* 自动显示滚动条 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li>当容器的内容宽度或高度超过 200px 或 100px 时，浏览器会自动显示水平或垂直滚动条，以便用户可以滚动查看内容。</li>
</ul>
<h3 id="各属性值示例"><a href="#各属性值示例" class="headerlink" title="各属性值示例"></a>各属性值示例</h3><ol>
<li><code>visible</code>：</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">overflow</span>: visible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内容会溢出容器，不会显示滚动条。</p>
<ol start="2">
<li><code>hidden</code>：</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内容会被剪裁，溢出部分不可见，不会显示滚动条。</p>
<ol start="3">
<li><code>scroll</code>：</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">overflow</span>: scroll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论内容是否溢出，都会显示滚动条。</p>
<ol start="4">
<li><code>auto</code>：</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当内容溢出时，浏览器会自动显示滚动条。</p>
<h3 id="组合使用-overflow-x-和-overflow-y"><a href="#组合使用-overflow-x-和-overflow-y" class="headerlink" title="组合使用 overflow-x 和 overflow-y"></a>组合使用 <code>overflow-x</code> 和 <code>overflow-y</code></h3><p>有时你可能需要分别控制水平方向和垂直方向的溢出行为，这时可以使用 <code>overflow-x</code> 和 <code>overflow-y</code> 属性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">overflow-x</span>: auto; <span class="comment">/* 水平方向自动显示滚动条 */</span></span><br><span class="line">  <span class="attribute">overflow-y</span>: hidden; <span class="comment">/* 垂直方向隐藏溢出内容 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>overflow</code> 属性仅在元素具有限定的宽度和高度时起作用。</li>
<li><code>overflow</code> 属性常用于创建滚动区域，特别是在布局响应式设计中。</li>
</ul>
<p>通过合理使用 <code>overflow</code> 属性，可以更好地控制元素内容在水平方向和垂直方向上的显示方式，提升页面的可读性和用户体验。</p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Axios学习</title>
    <url>/2024/05/24/Axios%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Axiso库"><a href="#Axiso库" class="headerlink" title="Axiso库"></a>Axiso库</h1><p><strong>官方介绍：</strong></p>
<p>Axios 是一个基于 <em><a href="https://javascript.info/promise-basics">promise</a></em> 网络请求库，作用于<a href="https://nodejs.org/"><code>node.js</code></a> 和浏览器中。 它是 <em><a href="https://www.lullabot.com/articles/what-is-an-isomorphic-application">isomorphic</a></em> 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js <code>http</code> 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。</p>
<p><strong>axios官方文档：</strong><a href="https://www.axios-http.cn/docs/intro">https://www.axios-http.cn/docs/intro</a></p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>2024.5.24 第一次更新，主要学习了一下Axiso的基本用法</p>
<h2 id="功能特点"><a href="#功能特点" class="headerlink" title="功能特点"></a>功能特点</h2><ul>
<li><p>在浏览器中发送XMLHttpRequest请求</p>
<blockquote>
<p>避免了兼容性问题,fech是存在兼容性问题的</p>
</blockquote>
</li>
<li><p>在node.js中发送http请求</p>
<blockquote>
<p>不需要关心在不同的环境用不同的API，axiso会自动识别环境，在不同的环境下用的都是同一个API</p>
</blockquote>
</li>
<li><p>支持 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> API</p>
</li>
<li><p>拦截请求和响应</p>
</li>
<li><p>转换请求和响应数据</p>
</li>
<li><p>取消请求</p>
</li>
<li><p>超时处理</p>
</li>
<li><p>查询参数序列化支持嵌套项处理</p>
</li>
<li><p>自动将请求体序列化为：</p>
<ul>
<li>JSON (<code>application/json</code>)</li>
<li>Multipart &#x2F; FormData (<code>multipart/form-data</code>)</li>
<li>URL encoded form (<code>application/x-www-form-urlencoded</code>)</li>
</ul>
</li>
<li><p>将 HTML Form 转换成 JSON 进行请求</p>
</li>
<li><p>自动转换JSON数据</p>
</li>
<li><p>获取浏览器和 node.js 的请求进度，并提供额外的信息（速度、剩余时间）</p>
</li>
<li><p>为 node.js 设置带宽限制</p>
</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote>
<p>npm install axios</p>
</blockquote>
<h2 id="在需要使用的js文件中引入axios"><a href="#在需要使用的js文件中引入axios" class="headerlink" title="在需要使用的js文件中引入axios"></a>在需要使用的js文件中引入axios</h2><blockquote>
<p>import axios from ‘axios’</p>
</blockquote>
<h2 id="axios请求方法"><a href="#axios请求方法" class="headerlink" title="axios请求方法"></a>axios请求方法</h2><h3 id="config请求配置"><a href="#config请求配置" class="headerlink" title="config请求配置"></a>config请求配置</h3><ul>
<li><p>url： <code>url</code> 是用于请求的服务器 URL</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">url</span>: <span class="string">&#x27;/user&#x27;</span>,</span><br></pre></td></tr></table></figure>
</li>
<li><p>method：<code>method</code> 是创建请求时使用的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>, <span class="comment">// 默认值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>baseURL： <code>baseURL</code> 将自动加在 <code>url</code> 前面，除非 <code>url</code> 是一个绝对 URL。<br>它可以通过设置一个 <code>baseURL</code> 便于为 axios 实例的方法传递相对 URL</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span></span><br><span class="line">  <span class="comment">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span></span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://some-domain.com/api/&#x27;</span>,</span><br></pre></td></tr></table></figure>
</li>
<li><p>transformRequest： <code>transformRequest</code> 允许在向服务器发送前，修改请求数据。</p>
<ul>
<li>它只能用于 ‘PUT’, ‘POST’ 和 ‘PATCH’ 这几个请求方法。</li>
<li>数组中最后一个函数必须返回一个字符串， 一个Buffer实例，ArrayBuffer，FormData，或 Stream。</li>
<li>你可以修改请求头。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">transformRequest</span>: [<span class="keyword">function</span> (<span class="params">data, headers</span>) &#123;</span><br><span class="line">    <span class="comment">// 对发送的 data 进行任意转换处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br></pre></td></tr></table></figure>
</li>
<li><p>transformResponse：<code>transformResponse</code> 在传递给 then&#x2F;catch 前，允许修改响应数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">transformResponse</span>: [<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// 对接收的 data 进行任意转换处理</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;],</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义请求头</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">headers</span>: &#123;<span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span>&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>params：<code>params</code> 是与请求一起发送的 URL 参数，必须是一个简单对象或 URLSearchParams 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>paramsSerializer：<code>paramsSerializer</code>是可选方法，主要用于序列化<code>params</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">paramsSerializer</span>: <span class="keyword">function</span> (<span class="params">params</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Qs</span>.<span class="title function_">stringify</span>(params, &#123;<span class="attr">arrayFormat</span>: <span class="string">&#x27;brackets&#x27;</span>&#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>data：<code>data</code> 是作为请求体被发送的数据</p>
<ul>
<li>仅适用 ‘PUT’, ‘POST’, ‘DELETE 和 ‘PATCH’ 请求方法</li>
<li>在没有设置 <code>transformRequest</code> 时，则必须是以下类型之一:<ul>
<li>string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</li>
<li>浏览器专属: FormData, File, Blob</li>
<li>Node 专属: Stream, Buffer</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>timeout：<code>timeout</code> 指定请求超时的毫秒数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果请求时间超过 `timeout` 的值，则请求会被中断</span></span><br><span class="line"><span class="attr">timeout</span>: <span class="number">1000</span>, <span class="comment">// 默认值是 `0` (永不超时)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>withCredentials：<code>withCredentials</code> 表示跨域请求时是否需要使用凭证</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">withCredentials</span>: <span class="literal">false</span>, <span class="comment">// default</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>adapter：<code>adapter</code> 允许自定义处理请求，这使测试更加容易。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回一个 promise 并提供一个有效的响应</span></span><br><span class="line"><span class="attr">adapter</span>: <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>responseEncoding：<code>responseEncoding</code> 表示用于解码响应的编码 (Node.js 专属)</p>
<blockquote>
<p>注意：忽略 <code>responseType</code> 的值为 ‘stream’，或者是客户端请求</p>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">responseEncoding</span>: <span class="string">&#x27;utf8&#x27;</span>, <span class="comment">// 默认值</span></span><br></pre></td></tr></table></figure>

<p>更多参数，查询：<a href="https://www.axios-http.cn/docs/req_config">https://www.axios-http.cn/docs/req_config</a></p>
<h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><p><code>axios(config)</code></p>
<h5 id="axios-config-——post请求"><a href="#axios-config-——post请求" class="headerlink" title="axios(config)——post请求"></a>axios(config)——<strong>post请求</strong></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发起一个post请求</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;/user/12345&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="axios-config-——get请求"><a href="#axios-config-——get请求" class="headerlink" title="axios(config)——get请求"></a>axios(config)——<strong>get请求</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 node.js 用GET请求获取远程图片</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;http://bit.ly/2mTM3nY&#x27;</span>,</span><br><span class="line">  <span class="attr">responseType</span>: <span class="string">&#x27;stream&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    response.<span class="property">data</span>.<span class="title function_">pipe</span>(fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;ada_lovelace.jpg&#x27;</span>))</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h5 id="axios-url-config"><a href="#axios-url-config" class="headerlink" title="axios(url[, config])"></a>axios(url[, config])</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发起一个 GET 请求 (默认请求方式)</span></span><br><span class="line"><span class="title function_">axios</span>(<span class="string">&#x27;/user/12345&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="请求别名"><a href="#请求别名" class="headerlink" title="请求别名"></a>请求别名</h3><h5 id="axios-request-config"><a href="#axios-request-config" class="headerlink" title="axios.request(config)"></a>axios.request(config)<a href="https://www.axios-http.cn/docs/api_intro#axiosrequestconfig"></a></h5><h5 id="axios-get-url-config"><a href="#axios-get-url-config" class="headerlink" title="axios.get(url[, config])"></a>axios.get(url[, config])<a href="https://www.axios-http.cn/docs/api_intro#axiosgeturl-config"></a></h5><h5 id="axios-delete-url-config"><a href="#axios-delete-url-config" class="headerlink" title="axios.delete(url[, config])"></a>axios.delete(url[, config])<a href="https://www.axios-http.cn/docs/api_intro#axiosdeleteurl-config"></a></h5><h5 id="axios-head-url-config"><a href="#axios-head-url-config" class="headerlink" title="axios.head(url[, config])"></a>axios.head(url[, config])<a href="https://www.axios-http.cn/docs/api_intro#axiosheadurl-config"></a></h5><h5 id="axios-options-url-config"><a href="#axios-options-url-config" class="headerlink" title="axios.options(url[, config])"></a>axios.options(url[, config])<a href="https://www.axios-http.cn/docs/api_intro#axiosoptionsurl-config"></a></h5><h5 id="axios-post-url-data-config"><a href="#axios-post-url-data-config" class="headerlink" title="axios.post(url[, data[, config]])"></a>axios.post(url[, data[, config]])<a href="https://www.axios-http.cn/docs/api_intro#axiosposturl-data-config"></a></h5><h5 id="axios-put-url-data-config"><a href="#axios-put-url-data-config" class="headerlink" title="axios.put(url[, data[, config]])"></a>axios.put(url[, data[, config]])<a href="https://www.axios-http.cn/docs/api_intro#axiosputurl-data-config"></a></h5><h5 id="axios-patch-url-data-config"><a href="#axios-patch-url-data-config" class="headerlink" title="axios.patch(url[, data[, config]])"></a>axios.patch(url[, data[, config]])<a href="https://www.axios-http.cn/docs/api_intro#axiospatchurl-data-config"></a></h5><h5 id="axios-postForm-url-data-config"><a href="#axios-postForm-url-data-config" class="headerlink" title="axios.postForm(url[, data[, config]])"></a>axios.postForm(url[, data[, config]])<a href="https://www.axios-http.cn/docs/api_intro#axiospostformurl-data-config"></a></h5><h5 id="axios-putForm-url-data-config"><a href="#axios-putForm-url-data-config" class="headerlink" title="axios.putForm(url[, data[, config]])"></a>axios.putForm(url[, data[, config]])<a href="https://www.axios-http.cn/docs/api_intro#axiosputformurl-data-config"></a></h5><h5 id="axios-patchForm-url-data-config"><a href="#axios-patchForm-url-data-config" class="headerlink" title="axios.patchForm(url[, data[, config]])"></a>axios.patchForm(url[, data[, config]])</h5><h3 id="常用的两个"><a href="#常用的两个" class="headerlink" title="常用的两个"></a>常用的两个</h3><h4 id="axios-get"><a href="#axios-get" class="headerlink" title="axios.get"></a>axios.get</h4><h4 id="axios-post"><a href="#axios-post" class="headerlink" title="axios.post"></a>axios.post</h4><p>Url:请求地址</p>
<p>data：请求体</p>
<p>config：配置</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <tags>
        <tag>Axios</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode快捷键(mac中)</title>
    <url>/2024/05/23/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="vscode快捷键-mac中"><a href="#vscode快捷键-mac中" class="headerlink" title="vscode快捷键(mac中)"></a>vscode快捷键(mac中)</h1><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p>选中需要缩进的行，按住 <code>Command+]</code> 键。</p>
]]></content>
      <tags>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-父子组件的通信</title>
    <url>/2024/05/18/Vue-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="Vue-父子组件的通信"><a href="#Vue-父子组件的通信" class="headerlink" title="Vue-父子组件的通信"></a>Vue-父子组件的通信</h1><p>在 Vue.js 中，父子组件之间的通信可以通过 props 和 events 来实现。下面分别介绍了 props 和 events 的用法：</p>
<h3 id="使用-Props（父传子）："><a href="#使用-Props（父传子）：" class="headerlink" title="使用 Props（父传子）："></a>使用 Props（父传子）：</h3><ul>
<li>父组件可以通过 props 向子组件传递数据。</li>
<li>在子组件中，props 是响应式的，即当父组件的数据发生变化时，子组件会自动更新。</li>
<li>父组件通过在子组件上使用属性绑定的方式传递数据。</li>
</ul>
<p><strong>父组件：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ChildComponent :message=&quot;parentMessage&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import ChildComponent from &#x27;./ChildComponent.vue&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      parentMessage: &#x27;Hello from Parent&#x27;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComponent,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>子组件：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&#x27;message&#x27;],</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="使用-Events（子传父）："><a href="#使用-Events（子传父）：" class="headerlink" title="使用 Events（子传父）："></a>使用 Events（子传父）：</h3><ul>
<li>子组件可以通过 events 向父组件发送消息。</li>
<li>在子组件中使用 <code>$emit</code> 方法触发一个自定义事件，并传递数据。</li>
<li>父组件通过在子组件上监听自定义事件来接收子组件发送的消息。</li>
</ul>
<p><strong>父组件：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ChildComponent @child-event=&quot;handleChildEvent&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import ChildComponent from &#x27;./ChildComponent.vue&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleChildEvent(data) &#123;</span><br><span class="line">      console.log(&#x27;Received data from child:&#x27;, data);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComponent,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>子组件：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;sendMessage&quot;&gt;Send Message to Parent&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sendMessage() &#123;</span><br><span class="line">      this.$emit(&#x27;child-event&#x27;, &#x27;Hello from Child&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>通过 props 和 events，父子组件之间可以方便地进行通信，实现数据的传递和交互。</p>
]]></content>
  </entry>
  <entry>
    <title>vue文档学习</title>
    <url>/2024/05/18/vue%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h1><p>vue官方文档 <a href="https://cn.vuejs.org/guide/introduction.html">https://cn.vuejs.org/guide/introduction.html</a></p>
<p>基于vue方法文档的学习笔记，初学时主要记录基础知识，深度学习后希望能加上自己的理解！</p>
<h3 id="更新时间"><a href="#更新时间" class="headerlink" title="更新时间"></a>更新时间</h3><p>2024.05.18第一次更新</p>
<h2 id="什么是Vue"><a href="#什么是Vue" class="headerlink" title="什么是Vue"></a>什么是Vue</h2><p>一款用于构建用户界面的 （JavaScript ）渐进式框架框架</p>
<p>两个功能：</p>
<ul>
<li><strong>声明式渲染</strong>：vue的模板语法使得我们可以声明式地描述HTML和JS状态之间的关系</li>
<li><strong>响应性</strong>：自动跟踪JS状态并响应式地更新DOM</li>
</ul>
<h2 id="Vue可以使用的场景"><a href="#Vue可以使用的场景" class="headerlink" title="Vue可以使用的场景"></a>Vue可以使用的场景</h2><ul>
<li>无需构建步骤，渐进式增强静态的 HTML</li>
<li>在任何页面中作为 Web Components 嵌入</li>
<li>单页应用 (SPA)</li>
<li>全栈 &#x2F; 服务端渲染 (SSR)</li>
<li>Jamstack &#x2F; 静态站点生成 (SSG)</li>
<li>开发桌面端、移动端、WebGL，甚至是命令行终端中的界面</li>
</ul>
<h2 id="单文件组件（SFC——-vue"><a href="#单文件组件（SFC——-vue" class="headerlink" title="单文件组件（SFC——*.vue)"></a>单文件组件（SFC——*.vue)</h2><p>vue的标志性功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Vue组件的书写风格"><a href="#Vue组件的书写风格" class="headerlink" title="Vue组件的书写风格"></a>Vue组件的书写风格</h2><h3 id="选项式API-（Option-API）"><a href="#选项式API-（Option-API）" class="headerlink" title="选项式API （Option API）"></a>选项式API （Option API）</h3><ul>
<li>用对象来描述组件逻辑</li>
<li>对象包括data、methos、mouted等属性，这些属性都是可选式的（我自己的理解，不一定对）</li>
<li>选项定义的属性会暴露在函数内部的this上（即可以通过this访问到这个属性），this指向当前组件的实例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  // data() 返回的属性将会成为响应式的状态</span><br><span class="line">  // 并且暴露在 `this` 上</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // methods 是一些用来更改状态与触发更新的函数</span><br><span class="line">  // 它们可以在模板中作为事件处理器绑定</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      this.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 生命周期钩子会在组件生命周期的各个不同阶段被调用</span><br><span class="line">  // 例如这个函数就会在组件挂载完成后被调用</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(`The initial count is $&#123;this.count&#125;.`)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<h3 id="组合式API（Composition-API）"><a href="#组合式API（Composition-API）" class="headerlink" title="组合式API（Composition API）"></a>组合式API（Composition API）</h3><ul>
<li>可以使用导入的API函数描述组件逻辑</li>
<li>组合式API与<code>&lt;script setup&gt;</code>搭配使用，其中<code>setup</code>是一个标识，使得我们可以更简洁地使用组合式API（会在编译时做一些处理）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, onMounted &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">// 响应式状态</span><br><span class="line">const count = ref(0)</span><br><span class="line"></span><br><span class="line">// 用来修改状态、触发更新的函数</span><br><span class="line">function increment() &#123;</span><br><span class="line">  count.value++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 生命周期钩子</span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">  console.log(`The initial count is $&#123;count.value&#125;.`)</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;increment&quot;&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="两者之间的异同"><a href="#两者之间的异同" class="headerlink" title="两者之间的异同"></a>两者之间的异同</h3><ul>
<li>选项式API基于组件式API</li>
<li>选项式有面对对象的思想，对初学者更友好，强制按照选项来组织代码</li>
<li>组件式的核心思想是直接在函数作用域内定义响应式状态变量，并从多个函数中得到的状态组合起来处理复杂问题。更自由、灵活，但更难理解（确实，我不太能理解）</li>
</ul>
<h2 id="互动教程（组件式API-SFC）"><a href="#互动教程（组件式API-SFC）" class="headerlink" title="互动教程（组件式API+SFC）"></a>互动教程（组件式API+SFC）</h2><h3 id="响应式变量声明方式"><a href="#响应式变量声明方式" class="headerlink" title="响应式变量声明方式"></a>响应式变量声明方式</h3><p>说的明白点，就是动态的数据绑定，在reactive或ref中声明的变量可以响应式地用在html中</p>
<h4 id="reactive-声明"><a href="#reactive-声明" class="headerlink" title="reactive()声明"></a>reactive()声明</h4><ul>
<li>reactive只适用于对象（包括数组和内置类型，如Map和Set）</li>
<li>reactive创建的对象时JS Proxy，行为与普通对象一致</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter.<span class="property">count</span>) <span class="comment">// 0</span></span><br><span class="line">counter.<span class="property">count</span>++</span><br></pre></td></tr></table></figure>



<h4 id="ref"><a href="#ref" class="headerlink" title="ref()"></a>ref()</h4><ul>
<li>ref接收任意类型数据</li>
<li>返回值是一个对象，可以通过对象.value属性访问数据</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> message = <span class="title function_">ref</span>(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="property">value</span>) <span class="comment">// &quot;Hello World!&quot;</span></span><br><span class="line">message.<span class="property">value</span> = <span class="string">&#x27;Changed&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="在模板template中使用响应式状态"><a href="#在模板template中使用响应式状态" class="headerlink" title="在模板template中使用响应式状态"></a>在模板template中使用响应式状态</h3><p>响应式状态暂时我喜欢理解为响应式变量</p>
<ul>
<li>使用<code>&#123;&#123;&#125;&#125;</code>使用，并且ref中的对象的value可以不用message.value去访问，而是可以使用message直接访问（因为会被自动解包）</li>
<li><code>&#123;&#123;&#125;&#125;</code>中不限制于变量名，也可以是表达式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//变量写法</span><br><span class="line">&lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;Count is: &#123;&#123; counter.count &#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">//表达式写法</span><br><span class="line">&lt;h1&gt;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>



<h3 id="Attribute绑定（v-bind）"><a href="#Attribute绑定（v-bind）" class="headerlink" title="Attribute绑定（v-bind）"></a>Attribute绑定（v-bind）</h3><ul>
<li><p>Attribute n.属性，特质，在编程中通常用来描述数据对象的特征</p>
</li>
<li><p>v-bind用于绑定一个动态值，时v-开头的一种特殊Attribute</p>
</li>
<li><p>绑定的值可以是calss，可以是id，也可以是一些参数</p>
</li>
<li><p>可以简写为<code>:</code></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//语法糖</span><br><span class="line">&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const titleClass = ref(&#x27;title&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1 :class=&quot;titleClass&quot;&gt;Make me red&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.title &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>



<h3 id="事件监听（v-on）"><a href="#事件监听（v-on）" class="headerlink" title="事件监听（v-on）"></a>事件监听（v-on）</h3><ul>
<li><p>使用v-on监听DOM事件</p>
</li>
<li><p>简写为@</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;button v-on:click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">//简写</span><br><span class="line">&lt;button @click=&quot;increment&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在script中声明回调函数increment</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const count = ref(0)</span><br><span class="line"></span><br><span class="line">function increment() &#123;</span><br><span class="line">  // 更新组件状态</span><br><span class="line">  count.value++</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="表单的双向绑定"><a href="#表单的双向绑定" class="headerlink" title="表单的双向绑定"></a>表单的双向绑定</h3><h4 id="使用v-bind-v-on"><a href="#使用v-bind-v-on" class="headerlink" title="使用v-bind+v-on"></a>使用v-bind+v-on</h4><p>当v-on监听到表单内容的变化，就使用回调函数获取到表单的新内容，更新数据后，重新响应在v-bind绑定的组件上</p>
<h4 id="使用v-model（常用于表单、单选、多选、下拉框）"><a href="#使用v-model（常用于表单、单选、多选、下拉框）" class="headerlink" title="使用v-model（常用于表单、单选、多选、下拉框）"></a>使用v-model（常用于表单、单选、多选、下拉框）</h4><ul>
<li>v-model是实质是上述方法的语法糖</li>
<li>V-model将绑定的值与input中的值自动同步，不需要在使用事件处理函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//用法</span><br><span class="line">&lt;input v-model=&quot;text&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//例子</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const text = ref(&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input v-model=&quot;text&quot; placeholder=&quot;Type here&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<h3 id="条件渲染（v-if）"><a href="#条件渲染（v-if）" class="headerlink" title="条件渲染（v-if）"></a>条件渲染（v-if）</h3><ul>
<li><code>v-if</code>，只有在awesome为<code>true</code>时，<code>h1</code>标签才会被渲染</li>
<li><code>v-else-if</code>和<code>v-else</code>用法与JS中<code>if-else if-else</code>的用法基本一致</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//v-if</span><br><span class="line">&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">//v-else</span><br><span class="line">&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;</span><br></pre></td></tr></table></figure>



<h3 id="列表渲染（v-for）"><a href="#列表渲染（v-for）" class="headerlink" title="列表渲染（v-for）"></a>列表渲染（v-for）</h3><ul>
<li><p>v-for用于循环渲染</p>
</li>
<li><p>给每个 todo 对象设置了唯一的 <code>id</code>，并且将它作为<a href="https://cn.vuejs.org/api/built-in-special-attributes.html#key">特殊的 <code>key</code> attribute</a> 绑定到每个 <code>&lt;li&gt;</code>。<code>key</code> 使得 Vue 能够精确的移动每个 <code>&lt;li&gt;</code>，以匹配对应的对象在数组中的位置。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot;&gt;</span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">//在数组中新增数据</span><br><span class="line">todos.value.push(newTodo)</span><br><span class="line"></span><br><span class="line">//在数组中删除数据，过滤数据</span><br><span class="line">todos.value = todos.value.filter(/* ... */)</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">// 给每个 todo 对象一个唯一的 id</span><br><span class="line">let id = 0</span><br><span class="line"></span><br><span class="line">const newTodo = ref(&#x27;&#x27;)</span><br><span class="line">const todos = ref([</span><br><span class="line">  &#123; id: id++, text: &#x27;Learn HTML&#x27; &#125;,</span><br><span class="line">  &#123; id: id++, text: &#x27;Learn JavaScript&#x27; &#125;,</span><br><span class="line">  &#123; id: id++, text: &#x27;Learn Vue&#x27; &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">function addTodo() &#123;</span><br><span class="line">  // 新增todo</span><br><span class="line">  if(newTodo.value != &#x27;&#x27;)&#123;</span><br><span class="line">    console.log(newTodo.value);</span><br><span class="line">    todos.value.push(&#123;</span><br><span class="line">      id: id++,</span><br><span class="line">      text: newTodo.value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  newTodo.value = &#x27;&#x27;//添加完数据后要重置为空</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function removeTodo(todo) &#123;</span><br><span class="line">  // 删除todo</span><br><span class="line">  todos.value = todos.value.filter((item)=&gt;&#123;</span><br><span class="line">    return item!=todo;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;form @submit.prevent=&quot;addTodo&quot;&gt;</span><br><span class="line">    &lt;input v-model=&quot;newTodo&quot; required placeholder=&quot;new todo&quot;&gt;</span><br><span class="line">    &lt;button&gt;Add Todo&lt;/button&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot;&gt;</span><br><span class="line">      &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">      &lt;button @click=&quot;removeTodo(todo)&quot;&gt;X&lt;/button&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<h4 id="计算属性（computed）"><a href="#计算属性（computed）" class="headerlink" title="计算属性（computed）"></a>计算属性（computed）</h4><ul>
<li>创建一个计算属性 ref，这个 ref 会动态地根据其他响应式数据源来计算其 <code>.value</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; ref, computed &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const hideCompleted = ref(false)</span><br><span class="line">const todos = ref([</span><br><span class="line">  /* ... */</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">const filteredTodos = computed(() =&gt; &#123;</span><br><span class="line">  // 根据 `todos.value` &amp; `hideCompleted.value`</span><br><span class="line">  // 返回过滤后的 todo 项目</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">- &lt;li v-for=&quot;todo in todos&quot;&gt;</span><br><span class="line">+ &lt;li v-for=&quot;todo in filteredTodos&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, computed &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">let id = 0</span><br><span class="line"></span><br><span class="line">const newTodo = ref(&#x27;&#x27;)</span><br><span class="line">const hideCompleted = ref(false)</span><br><span class="line">const todos = ref([</span><br><span class="line">  &#123; id: id++, text: &#x27;Learn HTML&#x27;, done: true &#125;,</span><br><span class="line">  &#123; id: id++, text: &#x27;Learn JavaScript&#x27;, done: true &#125;,</span><br><span class="line">  &#123; id: id++, text: &#x27;Learn Vue&#x27;, done: false &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">//当hideCompleted为true的时候，应该隐藏掉todos中done属性为ture的属性，所以过滤时返回done为false的属性的对象</span><br><span class="line">const filteredTodos = computed(() =&gt; &#123;</span><br><span class="line">  return hideCompleted.value</span><br><span class="line">    ? todos.value.filter((t) =&gt; !t.done)</span><br><span class="line">    : todos.value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function addTodo() &#123;</span><br><span class="line">  todos.value.push(&#123; id: id++, text: newTodo.value, done: false &#125;)</span><br><span class="line">  newTodo.value = &#x27;&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function removeTodo(todo) &#123;</span><br><span class="line">  todos.value = todos.value.filter((t) =&gt; t !== todo)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;form @submit.prevent=&quot;addTodo&quot;&gt;</span><br><span class="line">    &lt;input v-model=&quot;newTodo&quot; required placeholder=&quot;new todo&quot;&gt;</span><br><span class="line">    &lt;button&gt;Add Todo&lt;/button&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;todo in filteredTodos&quot; :key=&quot;todo.id&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;&gt;</span><br><span class="line">      &lt;span :class=&quot;&#123; done: todo.done &#125;&quot;&gt;&#123;&#123; todo.text &#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;button @click=&quot;removeTodo(todo)&quot;&gt;X&lt;/button&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  &lt;button @click=&quot;hideCompleted = !hideCompleted&quot;&gt;</span><br><span class="line">    &#123;&#123; hideCompleted ? &#x27;Show all&#x27; : &#x27;Hide completed&#x27; &#125;&#125;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.done &#123;</span><br><span class="line">  text-decoration: line-through;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>



<h3 id="生命周期和模板引用"><a href="#生命周期和模板引用" class="headerlink" title="生命周期和模板引用"></a>生命周期和模板引用</h3><ul>
<li>当我们需要手动操作DOM时，会需要使用<code>模板引用</code>，也就是指向模板中的一个DOM元素的ref</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;p ref=&quot;pElementRef&quot;&gt;hello&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">//使用同名ref访问该引用</span><br><span class="line">const pElementRef = ref(null)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//要在挂载之后执行代码，我们可以使用 onMounted() 函数：</span><br><span class="line">import &#123; onMounted &#125; from &#x27;vue&#x27;</span><br><span class="line">  //ref引用的是一个DOM元素，在这个例子中，就是一个p标签</span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">  // 此时组件已经挂载。</span><br><span class="line">   pElementRef.value.textContent = &quot;你好&quot;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>此时，这个 ref 使用 null 值来初始化。这是因为当&lt;script setup&gt; 执行时，DOM 元素还不存在。模板引用 ref 只能在组件挂载后访问。</p>
<ul>
<li><code>onMounted</code>被称为<strong>生命周期钩子</strong>——它允许我们注册一个在组件的特定生命周期调用的回调函数。还有一些其他的钩子如 <code>onUpdated</code> 和 <code>onUnmounted</code>。</li>
</ul>
<h3 id="侦听器-watch"><a href="#侦听器-watch" class="headerlink" title="侦听器(watch)"></a>侦听器(watch)</h3><p>有时我们需要响应性地执行一些“副作用”——例如，当一个数字改变时将其输出到控制台。我们可以通过侦听器来实现它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; ref, watch &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const count = ref(0)</span><br><span class="line"></span><br><span class="line">watch(count, (newCount) =&gt; &#123;</span><br><span class="line">  // 没错，console.log() 是一个副作用</span><br><span class="line">  console.log(`new count is: $&#123;newCount&#125;`)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>















]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口专项训练</title>
    <url>/2024/05/16/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<h1 id="滑动窗口专项训练"><a href="#滑动窗口专项训练" class="headerlink" title="滑动窗口专项训练"></a>滑动窗口专项训练</h1><h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>2024.5.17 第一次记录</p>
<h2 id="一般解题步骤"><a href="#一般解题步骤" class="headerlink" title="一般解题步骤"></a>一般解题步骤</h2><p>待更新</p>
<p>1.定义需要维护的变量</p>
<p>可能是：</p>
<ul>
<li>哈希表（map或set）</li>
<li>最短&#x2F;最长长度</li>
</ul>
<p>2.初始化滑动窗口，<code>start</code>和<code>end</code>一般都初始化为0（如果是双指针两边夹的情况，一般都是贪心？）</p>
<ol start="3">
<li></li>
</ol>
<h2 id="解题模板"><a href="#解题模板" class="headerlink" title="解题模板"></a>解题模板</h2><p>由于自己的理解还不够深刻，这里借鉴大佬的思路</p>
<p><a href="https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/solutions/879777/hua-dong-chuang-kou-zhen-di-jian-dan-yi-73bii">https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/solutions/879777/hua-dong-chuang-kou-zhen-di-jian-dan-yi-73bii</a></p>
<p>大佬的是python的版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">problemName</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># Step 1: 定义需要维护的变量们 (对于滑动窗口类题目，这些变量通常是最小长度，最大长度，或者哈希表)</span></span><br><span class="line">        x, y = ..., ...</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="comment"># Step 3: 更新需要维护的变量, 有的变量需要一个if语句来维护 (比如最大最小长度)</span></span><br><span class="line">            x = new_x</span><br><span class="line">            <span class="keyword">if</span> condition:</span><br><span class="line">                y = new_y</span><br><span class="line"></span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            ------------- 下面是两种情况，读者请根据题意二选1 -------------</span></span><br><span class="line"><span class="string">            &#x27;&#x27;&#x27;</span></span><br><span class="line">            <span class="comment"># Step 4 - 情况1</span></span><br><span class="line">            <span class="comment"># 如果题目的窗口长度固定：用一个if语句判断一下当前窗口长度是否超过限定长度 </span></span><br><span class="line">            <span class="comment"># 如果超过了，窗口左指针前移一个单位保证窗口长度固定, 在那之前, 先更新Step 1定义的(部分或所有)维护变量 </span></span><br><span class="line">            <span class="keyword">if</span> 窗口长度大于限定值:</span><br><span class="line">                <span class="comment"># 更新 (部分或所有) 维护变量 </span></span><br><span class="line">                <span class="comment"># 窗口左指针前移一个单位保证窗口长度固定</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Step 4 - 情况2</span></span><br><span class="line">            <span class="comment"># 如果题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment"># 如果当前窗口不合法时, 用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment"># 在左指针移动之前更新Step 1定义的(部分或所有)维护变量 </span></span><br><span class="line">            <span class="keyword">while</span> 不合法:</span><br><span class="line">                <span class="comment"># 更新 (部分或所有) 维护变量 </span></span><br><span class="line">                <span class="comment"># 不断移动窗口左指针直到窗口再次合法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Step 5: 返回答案</span></span><br><span class="line">        <span class="keyword">return</span> ...</span><br></pre></td></tr></table></figure>

<p>按照大佬是思路，改成JS的版本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> problemName = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="comment">// Step 1: 定义需要维护的变量们 (对于滑动窗口类题目，这些变量通常是最小长度，最大长度，或者哈希表)</span></span><br><span class="line">	<span class="keyword">let</span> [x, y] = ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口</span></span><br><span class="line">    <span class="keyword">let</span> st = <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">let</span> end = <span class="number">0</span>; end &lt; s.<span class="property">length</span>; s++)&#123;</span><br><span class="line">        <span class="comment">//Step 3: 更新需要维护的变量, 有的变量需要一个if语句来维护 (比如最大最小长度)</span></span><br><span class="line">        x = new_x;</span><br><span class="line">      	<span class="keyword">if</span>(condition)&#123;</span><br><span class="line">          y = new_y;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// Step 4 - 情况1</span></span><br><span class="line">            <span class="comment">// 如果题目的窗口长度固定：用一个if语句判断一下当前窗口长度是否超过限定长度 </span></span><br><span class="line">            <span class="comment">// 如果超过了，窗口左指针前移一个单位保证窗口长度固定, 在那之前, 先更新Step 1定义的(部分或所有)维护变量 </span></span><br><span class="line">            <span class="keyword">if</span>(窗口长度大于限定值)&#123;</span><br><span class="line">               <span class="comment">// 更新 (部分或所有) 维护变量 </span></span><br><span class="line">                <span class="comment">// 窗口左指针前移一个单位保证窗口长度固定</span></span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">            <span class="comment">// Step 4 - 情况2</span></span><br><span class="line">            <span class="comment">// 如果题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题</span></span><br><span class="line">            <span class="comment">// 如果当前窗口不合法时, 用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法</span></span><br><span class="line">            <span class="comment">// 在左指针移动之前更新Step 1定义的(部分或所有)维护变量 </span></span><br><span class="line">            <span class="keyword">while</span>(不合法)&#123;</span><br><span class="line">            	<span class="comment">//更新 (部分或所有) 维护变量 </span></span><br><span class="line">              <span class="comment">//不断移动窗口左指针直到窗口再次合法</span></span><br><span class="line">            &#125;           </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// Step 5: 返回答案</span></span><br><span class="line">  <span class="keyword">return</span> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="实战训练"><a href="#实战训练" class="headerlink" title="实战训练"></a>实战训练</h2><h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<p><strong>code:</strong></p>
<p>不用map，用set和单纯数组都行，数组的话就用include方法来查看字母是否已经存在于数组中，但是最好还是不要数组了，数组里面删除一个元素会很麻烦，主要还是哈希+滑动窗口的思想。</p>
<p>用set的话会简单一点点</p>
<p>带注释版本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//无重复字符的最长子串</span></span><br><span class="line">    <span class="comment">//ex</span></span><br><span class="line">    <span class="comment">// abcabcbb</span></span><br><span class="line">    <span class="comment">// abc -&gt; maxLen = 3</span></span><br><span class="line">    <span class="comment">//滑动窗口</span></span><br><span class="line">    <span class="comment">//1.定义需要维护的变量</span></span><br><span class="line">    <span class="keyword">let</span> maxLen = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> hash = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="comment">//2.定义窗口的首尾端，然后滑动窗口</span></span><br><span class="line">    <span class="keyword">let</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> end = <span class="number">0</span>; end &lt; s.<span class="property">length</span>; end++)&#123;<span class="comment">//第一次debug是end++写成s++了</span></span><br><span class="line">        <span class="comment">//维护变量</span></span><br><span class="line">        <span class="keyword">let</span> c = s[end];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//情况2:窗口可变,检查窗口是否合法，不合法就调整st指针直至合法  </span></span><br><span class="line">        <span class="comment">//在该题目中，不合法指的是，字符串中出现重复字符 </span></span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="title function_">has</span>(c))&#123;<span class="comment">//c字符不是第一次出现，窗口不合法</span></span><br><span class="line">            <span class="comment">//只要连续移动字符，直到新的窗口的字符中不包含第一次出现的c字符位置</span></span><br><span class="line">            <span class="keyword">while</span>( st &lt; end &amp;&amp; s[st] != c)&#123;</span><br><span class="line">                hash.<span class="title function_">delete</span>(s[st]);<span class="comment">//第二次debug，这一句和下面一句的顺序反了，如果先++在delet，那么相当于delet的是下一个字符，第一个字符永远都不会被移除</span></span><br><span class="line">                st++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//此时的st应该位于第一个窗口的第一个c字符处</span></span><br><span class="line">            st++;</span><br><span class="line">            <span class="comment">//现在窗口合法了</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//第一次出现</span></span><br><span class="line">            hash.<span class="title function_">set</span>(c, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//窗口的长度为end - st + 1 （左闭右闭区间）</span></span><br><span class="line">        <span class="comment">//如果是左闭右开区间，就是end - st</span></span><br><span class="line">        maxLen = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLen, end - st + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不带注释</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> maxLen = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> hash = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> end = <span class="number">0</span>; end &lt; s.<span class="property">length</span>; end++)&#123;</span><br><span class="line">        <span class="keyword">let</span> c = s[end];    </span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">            <span class="keyword">while</span>( st &lt; end &amp;&amp; s[st] != c)&#123;</span><br><span class="line">                hash.<span class="title function_">delete</span>(s[st]);</span><br><span class="line">                st++;</span><br><span class="line">            &#125; </span><br><span class="line">            st++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            hash.<span class="title function_">set</span>(c, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLen, end - st + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h3><p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></p>
<p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p><strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span><br></pre></td></tr></table></figure>

<p> <strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;, p = &quot;ab&quot;</span><br><span class="line">输出: [0,1,2]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br></pre></td></tr></table></figure>

<p><strong>Code:</strong></p>
<p>窗口不合理的情况比较复杂</p>
<p>带注释版本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">p</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findAnagrams = <span class="keyword">function</span>(<span class="params">s, p</span>) &#123;</span><br><span class="line">    <span class="comment">//哈希(异位词)+滑动窗口(子串)</span></span><br><span class="line">    <span class="comment">//异位词的特点是：</span></span><br><span class="line">    <span class="comment">//1.长度相等</span></span><br><span class="line">    <span class="comment">//2.每个字符的出现次数相等</span></span><br><span class="line">    <span class="keyword">let</span> hash = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> hash2 = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="comment">//初始化hash</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; p.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="title function_">has</span>(p[i]))&#123;</span><br><span class="line">            hash.<span class="title function_">set</span>(p[i], hash.<span class="title function_">get</span>(p[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> hash.<span class="title function_">set</span>(p[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化窗口，并开始滑动</span></span><br><span class="line">    <span class="keyword">let</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> end = <span class="number">0</span>; end &lt; s.<span class="property">length</span>; end++)&#123;</span><br><span class="line">        <span class="keyword">let</span> c = s[end];</span><br><span class="line">        <span class="keyword">if</span>(hash2.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">            hash2.<span class="title function_">set</span>(c, hash2.<span class="title function_">get</span>(c) + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> hash2.<span class="title function_">set</span>(c, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//窗口不合法1，没有这个字符,两个指针都跳到这个指针后面</span></span><br><span class="line">        <span class="keyword">if</span>(!hash.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">            <span class="keyword">while</span>(st != end + <span class="number">1</span>)&#123;<span class="comment">//debug1,一开始没有跳转到st = end+1，只是st++，这样是不对的，而且跳转完之后，一定要记得移除hash2中前面的（已经不在滑动窗口中的）字母</span></span><br><span class="line">                hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);</span><br><span class="line">                st++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(hash2.<span class="title function_">get</span>(c) &gt; hash.<span class="title function_">get</span>(c))&#123;</span><br><span class="line">            <span class="comment">//窗口不合法2,有这个字符，但是字符数多了,移动st，直到窗口中的c的字符数与hash中的字符数一致</span></span><br><span class="line">            <span class="keyword">while</span>(hash2.<span class="title function_">get</span>(c) != hash.<span class="title function_">get</span>(c))&#123;</span><br><span class="line">                hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);</span><br><span class="line">                st++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//窗口不合法3，窗口长度超过了</span></span><br><span class="line">        <span class="keyword">while</span>(end - st + <span class="number">1</span> &gt; p.<span class="property">length</span>)&#123;</span><br><span class="line">            hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);<span class="comment">//debug2，滑动了窗口，但是忘记处理hash2了</span></span><br><span class="line">            st++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(end - st + <span class="number">1</span> === p.<span class="property">length</span>)&#123;</span><br><span class="line">            res.<span class="title function_">push</span>(st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不带注释版本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">p</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findAnagrams = <span class="keyword">function</span>(<span class="params">s, p</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> hash = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> hash2 = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; p.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="title function_">has</span>(p[i]))&#123;</span><br><span class="line">            hash.<span class="title function_">set</span>(p[i], hash.<span class="title function_">get</span>(p[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> hash.<span class="title function_">set</span>(p[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> end = <span class="number">0</span>; end &lt; s.<span class="property">length</span>; end++)&#123;</span><br><span class="line">        <span class="keyword">let</span> c = s[end];</span><br><span class="line">        <span class="keyword">if</span>(hash2.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">            hash2.<span class="title function_">set</span>(c, hash2.<span class="title function_">get</span>(c) + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> hash2.<span class="title function_">set</span>(c, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!hash.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">            <span class="keyword">while</span>(st != end + <span class="number">1</span>)&#123;</span><br><span class="line">                hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);</span><br><span class="line">                st++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(hash2.<span class="title function_">get</span>(c) &gt; hash.<span class="title function_">get</span>(c))&#123;</span><br><span class="line">            <span class="keyword">while</span>(hash2.<span class="title function_">get</span>(c) != hash.<span class="title function_">get</span>(c))&#123;</span><br><span class="line">                hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);</span><br><span class="line">                st++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(end - st + <span class="number">1</span> &gt; p.<span class="property">length</span>)&#123;</span><br><span class="line">            hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);</span><br><span class="line">            st++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(end - st + <span class="number">1</span> === p.<span class="property">length</span>)&#123;</span><br><span class="line">            res.<span class="title function_">push</span>(st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



























]]></content>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划专项训练</title>
    <url>/2024/05/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A1%B9%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<h1 id="动态规划专项训练"><a href="#动态规划专项训练" class="headerlink" title="动态规划专项训练"></a>动态规划专项训练</h1><p>参考：代码随想录官⽹<a href="http://www.programmercarl.com/">www.programmercarl.com</a></p>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>第一次更新 2024.05.13</p>
<p>第二次更新 2024.05.17</p>
<h2 id="一般解题步骤"><a href="#一般解题步骤" class="headerlink" title="一般解题步骤"></a>一般解题步骤</h2><ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>​	dp数组（状态转移数组）可以是一维的可以是二维的</p>
<ol start="2">
<li>确定递推公式 （状态转移方程）</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<h2 id="实战训练"><a href="#实战训练" class="headerlink" title="实战训练"></a>实战训练</h2><h3 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h3><h4 id="1-斐波那契数"><a href="#1-斐波那契数" class="headerlink" title="1.斐波那契数"></a>1.斐波那契数</h4><p><a href="https://leetcode.cn/problems/fibonacci-number/">509. 斐波那契数</a></p>
<p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F(0) = 0，F(1) = 1</span><br><span class="line">F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure>

<p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) = F(1) + F(0) = 1 + 0 = 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) = F(2) + F(1) = 1 + 1 = 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：3</span><br><span class="line">解释：F(4) = F(3) + F(2) = 2 + 1 = 3</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 30</code></li>
</ul>
<p><strong>code：</strong></p>
<p>用模拟的思想做的，非dp</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fib = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> num1 = <span class="number">0</span>, num2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> cur;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cur = num1 + num2;</span><br><span class="line">        num1 = num2;</span><br><span class="line">        num2 = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>用动态规划来做</strong></p>
<ol>
<li><p>确定dp数组（dp table）以及下标的含义 </p>
<p>dp[i]表示第i个斐波那契数</p>
</li>
<li><p>确定递推公式</p>
<p>题目 中有 dp[i] &#x3D; dp[i - 1] + dp[i - 2]</p>
</li>
<li><p>dp数组如何初始化</p>
<p>题目中有 dp[0] &#x3D; 0 , dp[1] &#x3D; 1</p>
</li>
<li><p>确定遍历顺序</p>
<p>是从后向前还是从前向后，是一层还是两层，如果是两层，哪层在外面</p>
</li>
<li><p>打印推导dp数组（debug用的）</p>
</li>
</ol>
<h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h4><p><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></p>
<p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 45</code></li>
</ul>
<p><strong>code：</strong></p>
<p>在前面知识的基础上，我大概能了解到迈上第n阶的方法其实是有前面的迈上n-1和迈上n-2阶的种数有关的，但是如果没有关键点的想，很容易想岔去。</p>
<p>下面的代码是我第一个自己思考的代码，是错误的，一开始想的是想的是比如想要到第4阶，有可能是dp[1] + dp[3], dp[2]+ dp[2], dp[3] + dp[1]；但是如果这样想的话，所有种类中是会有重复值的。所以我也想到了要去重，但是去重的规律并没有找对；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="comment">//dp[i]表示爬到i阶楼梯，有dp[i]种方法</span></span><br><span class="line">    <span class="keyword">let</span> dp = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="comment">//初始化dp[]</span></span><br><span class="line">    <span class="comment">//状态转移方程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> cn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> k = <span class="number">1</span>; k &lt; i; k++)&#123;</span><br><span class="line">            cn += (dp[k] * dp[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//去除重复值</span></span><br><span class="line">        cn = cn - <span class="number">2</span> * i + <span class="number">5</span>;</span><br><span class="line">        dp.<span class="title function_">push</span>(cn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看了卡哥的视频解说，反复想了一下理解了，其实思路是可以有很多种的，但是如果想用动态规划的思路来写，关键点在于<code>状态转移</code>，如果从0阶开始向上迈，那么状态转移方程其实很不好把握，容易像我之前一样想岔了，会想：先走几阶有几种方法，后走几阶有几种方法，很容易把自己绕进去。</p>
<p>但是如果想要专注于状态转移，应该<strong>从台阶上往下看</strong>，而且必须注意状态转移的条件（即每次只能爬1或2个台阶），那么对于一个人来说，他走到n层台阶的上一个状态只可能有两种：</p>
<ol>
<li>上一个状态是走到了n-1个台阶，他是迈了一步才走到n台阶的</li>
<li>上一个状态是走到了n-2个台阶，他是迈了两步才走到n台阶的</li>
</ol>
<p>可以想到，这样递归出来的种类数其实是很干净的，不会存在重复值，因为不同于我第一次的想法，我第一次想的是（**step1:**从0-k有几种方法； **step2:**从k-n有几种方法），而动态规划中，强制了我的step2只能有一种方法。举个例子:</p>
<p>易得dp[1] &#x3D; 1, dp[2]&#x3D; 2</p>
<p>如果我想求dp[4]</p>
<p>先看看我原本的想法：可能性有先走一步，再走三步；先走二步，再走两步；先走三步，再走一步</p>
<p>那么这个<code>dp[4]=dp[1]*dp[3]+ dp[2]*dp[2]+dp[3]*dp[1]</code>，但是这样的递归推导是不干净的，因为里面存在了很多的重复值</p>
<p>再看看动态规划的思想：如果我想根据step1+step2的思路来思考的话，首先强制step2的方法只能有一种，即当走过step1方法到达中间的某个台阶后，我只能通过一种方法来到达台阶n。</p>
<p>虽然step只能有一种方法，但是step可以有两种情况：即先走 2步，然后走2步到n；或者先走3步，然后走1步到n；</p>
<p>由此可得到：dp[4] &#x3D; d[2] * 1 + d[3] * 1;</p>
<p>所以我才得出了dp的关键在于：到达这个状态的上一个状态是怎么样的，因为上一个状态总是通过一次操作（一次状态转移）达到这个状态，这样递归下来的数据才是干净的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="comment">//dp[i]表示爬到i阶楼梯，有dp[i]种方法</span></span><br><span class="line">    <span class="keyword">let</span> dp = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="comment">//状态转移方程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        dp.<span class="title function_">push</span>(dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]);<span class="comment">//可以不用维护数组，直接用变量来写，写法上一题斐波那契数写法一致，不写了这里</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h4><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></p>
<p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>
<p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p>
<p>请你计算并返回达到楼梯顶部的最低花费。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：cost = [10,15,20]</span><br><span class="line">输出：15</span><br><span class="line">解释：你将从下标为 1 的台阶开始。</span><br><span class="line">- 支付 15 ，向上爬两个台阶，到达楼梯顶部。</span><br><span class="line">总花费为 15 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：cost = [1,100,1,1,1,100,1,1,100,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：你将从下标为 0 的台阶开始。</span><br><span class="line">- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。</span><br><span class="line">- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。</span><br><span class="line">- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。</span><br><span class="line">- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。</span><br><span class="line">- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。</span><br><span class="line">- 支付 1 ，向上爬一个台阶，到达楼梯顶部。</span><br><span class="line">总花费为 6 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= cost.length &lt;= 1000</code></li>
<li><code>0 &lt;= cost[i] &lt;= 999</code></li>
</ul>
<p><strong>Code:</strong></p>
<p>这道题的难点在于搞清楚<code>ct[i]</code>到底指的是什么？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">cost</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ct[i]指的是到达i（此时i是楼顶）的最小消费</span></span><br><span class="line"><span class="keyword">var</span> minCostClimbingStairs = <span class="keyword">function</span>(<span class="params">cost</span>) &#123;</span><br><span class="line">    <span class="comment">//ct[i]达到i台阶的需要最小消费</span></span><br><span class="line">    <span class="keyword">if</span>(cost.<span class="property">length</span>==<span class="number">1</span>) <span class="keyword">return</span> cost[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(cost.<span class="property">length</span>==<span class="number">2</span>) <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">min</span>(cost[<span class="number">0</span>],cost[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">let</span> ct1 = <span class="title class_">Math</span>.<span class="title function_">min</span>(cost[<span class="number">0</span>],cost[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">let</span> ct = [<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= cost.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> cur = <span class="title class_">Math</span>.<span class="title function_">min</span>(ct[i - <span class="number">1</span>]+cost[i - <span class="number">1</span>], ct[i-<span class="number">2</span>]+cost[i-<span class="number">2</span>]);</span><br><span class="line">        ct.<span class="title function_">push</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ct[ct.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="不同路径【Mid】"><a href="#不同路径【Mid】" class="headerlink" title="不同路径【Mid】"></a>不同路径【Mid】</h4><p><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></p>
<p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://pic.leetcode.cn/1697422740-adxmsI-image.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向下</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 7, n = 3</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>

<h5 id="用dp来写"><a href="#用dp来写" class="headerlink" title="用dp来写"></a>用dp来写</h5><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><p>d[x][y]表示从start开始到点（x,y）有d[x][y]种走法</p>
<p>关键点在于只能向下走或者向右走，所以x和y都智能递增，是不可能回头的，所以对于边缘d[x][1]和d[1][y]都应该初始化为1；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">m</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> uniquePaths = <span class="keyword">function</span>(<span class="params">m, n</span>) &#123;</span><br><span class="line">    <span class="comment">//初始化d[x][y]边缘元素为1</span></span><br><span class="line">    <span class="keyword">let</span> d = <span class="keyword">new</span> <span class="title class_">Array</span>(m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="number">1</span>; x &lt;= m; x++)&#123;</span><br><span class="line">        d[x] = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span>) d[<span class="number">1</span>].<span class="title function_">fill</span>(<span class="number">1</span>);</span><br><span class="line">        d[x][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="number">2</span>; x &lt;= m; x++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> y = <span class="number">2</span>; y &lt;= n; y++)&#123;</span><br><span class="line">            d[x][y] = d[x][y - <span class="number">1</span>] + d[x - <span class="number">1</span>][y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(d);</span><br><span class="line">    <span class="keyword">return</span> d[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="DFS的基本写法"><a href="#DFS的基本写法" class="headerlink" title="DFS的基本写法"></a>DFS的基本写法</h5><p>在JavaScript中，深度优先搜索（DFS）的一般写法与其他编程语言类似。下面是一个基本的DFS函数示例，用于在一个图或树结构中进行深度优先搜索：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">node, visited</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (visited.<span class="title function_">has</span>(node)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理当前节点</span></span><br><span class="line">    visited.<span class="title function_">add</span>(node);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历当前节点的相邻节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> neighbor <span class="keyword">of</span> node.<span class="property">neighbors</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited.<span class="title function_">has</span>(neighbor)) &#123;</span><br><span class="line">            <span class="title function_">dfs</span>(neighbor, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化访问记录</span></span><br><span class="line"><span class="keyword">let</span> visited = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从起始节点开始进行DFS</span></span><br><span class="line"><span class="title function_">dfs</span>(startNode, visited);</span><br></pre></td></tr></table></figure>

<p>在这段代码中，<code>dfs()</code>函数表示深度优先搜索的递归函数，接受一个节点<code>node</code>和一个记录访问情况的<code>visited</code>集合作为参数。在DFS过程中，首先检查当前节点是否已经被访问过，如果已经访问过则直接返回；否则将当前节点标记为已访问，并递归地对当前节点的相邻节点进行DFS遍历。</p>
<p>用dfs,会超时，时间复杂度会达到2^(m+n)次，所以不合适，但是思路是可行的，如果m和n较小的话</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">m</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> uniquePaths = <span class="keyword">function</span>(<span class="params">m, n</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果越界，则认为这条路径不可行</span></span><br><span class="line">        <span class="keyword">if</span> (x &gt;= m || y &gt;= n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当到达终点时，返回1</span></span><br><span class="line">        <span class="keyword">if</span> (x === m - <span class="number">1</span> &amp;&amp; y === n - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 向右走 + 向下走</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">dfs</span>(x + <span class="number">1</span>, y) + <span class="title function_">dfs</span>(x, y + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="不同路径II"><a href="#不同路径II" class="headerlink" title="不同路径II"></a>不同路径II</h4><p><a href="https://leetcode.cn/problems/unique-paths-ii/">63. 不同路径 II</a></p>
<p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]</span><br><span class="line">输出：2</span><br><span class="line">解释：3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：obstacleGrid = [[0,1],[0,0]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == obstacleGrid.length</code></li>
<li><code>n == obstacleGrid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li><code>obstacleGrid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">obstacleGrid</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> uniquePathsWithObstacles = <span class="keyword">function</span>(<span class="params">obstacleGrid</span>) &#123;</span><br><span class="line">    <span class="comment">//当（x,y）点是障碍点时，那么达到x,y的路径只能是0条，多加一个判断条件</span></span><br><span class="line">    <span class="comment">//初始化d[x][y]</span></span><br><span class="line">    <span class="keyword">let</span> m = obstacleGrid.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> n = obstacleGrid[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> d = <span class="keyword">new</span> <span class="title class_">Array</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; m; x++)&#123;</span><br><span class="line">        d[x] = <span class="keyword">new</span> <span class="title class_">Array</span>(n);</span><br><span class="line">        <span class="keyword">let</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x==<span class="number">0</span> &amp;&amp; obstacleGrid[<span class="number">0</span>][y]!=<span class="number">1</span> &amp;&amp; y &lt; n)&#123;</span><br><span class="line">            d[<span class="number">0</span>][y++] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(x==<span class="number">0</span> &amp;&amp; y &lt; n)&#123;</span><br><span class="line">            d[<span class="number">0</span>][y++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[x][<span class="number">0</span>]!=<span class="number">1</span>)&#123;</span><br><span class="line">            d[x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(x &lt; m)&#123;<span class="comment">//这里有个易错点</span></span><br><span class="line">              <span class="comment">//如果在这个代码块种不加if(x &lt; m)d[x] = new Array(n);，那么因为当x++的时候，下一个d[x]是没有定义为数组的，如果此时使用d[x][0]就会报不能给undefined赋值的错误</span></span><br><span class="line">                d[x][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                x++;</span><br><span class="line">                <span class="keyword">if</span>(x &lt; m)d[x] = <span class="keyword">new</span> <span class="title class_">Array</span>(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="number">1</span>; x &lt; m; x++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> y = <span class="number">1</span>; y &lt; n; y++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[x][y]==<span class="number">1</span>)&#123;</span><br><span class="line">                d[x][y] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                d[x][y] = d[x-<span class="number">1</span>][y] + d[x][y-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(d);</span><br><span class="line">    <span class="keyword">return</span> d[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h4><p><a href="https://leetcode.cn/problems/integer-break/">343. 整数拆分</a></p>
<p>给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个 <strong>正整数</strong> 的和（ <code>k &gt;= 2</code> ），并使这些整数的乘积最大化。</p>
<p>返回 <em>你可以获得的最大乘积</em> 。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 58</code></li>
</ul>
<p><strong>code：</strong></p>
<p>把数尽量拆成平均的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> integerBreak = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxNum = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> k = <span class="number">2</span>; k &lt;= n ; k++)&#123;</span><br><span class="line">        <span class="keyword">let</span> m = n % k;<span class="comment">//余数</span></span><br><span class="line">        maxNum = <span class="title class_">Math</span>.<span class="title function_">max</span>(((((n-m)/k) + <span class="number">1</span>))**(m) * (((n-m)/k)) ** (k - m), maxNum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxNum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>dp思想:对于递推公式还是有点疑惑</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> integerBreak = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="comment">// 10 </span></span><br><span class="line">    <span class="comment">//  1 9</span></span><br><span class="line">    <span class="comment">// 2 8 </span></span><br><span class="line">    <span class="comment">// 3 7</span></span><br><span class="line">    <span class="comment">//4 6</span></span><br><span class="line">    <span class="comment">// 5 5</span></span><br><span class="line">    <span class="comment">// 6 4</span></span><br><span class="line">    <span class="comment">// 7 3</span></span><br><span class="line">    <span class="comment">// 8 2</span></span><br><span class="line">    <span class="comment">// 9 1</span></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);<span class="comment">//要先提前初始化为0</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 3  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= i/<span class="number">2</span>; j++)&#123;</span><br><span class="line">            dp[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(j*(i-j), j*dp[i-j],dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h4><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></p>
<p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 19</code></li>
</ul>
<p><strong>Code:</strong></p>
<p>如果清楚二叉搜索树的特性和知道用动态规划来做这道题，这道题其实还不算特别难，但是需要画图分析一下，其实就是找规律的过程。</p>
<p>由于二叉搜索树的特性（比跟节点小的数一定放在左子树中，比根节点大的数一定放在右子树中），所以就需要考虑当<code>j</code>作为根节点的时候，会有几种情况，在对<code>j</code>从<code>0</code>遍历到<code>n</code>；这里为什么从<code>0</code>开始遍历，后面会解释。</p>
<p>在实际分析前，需要注意的一点的，如果一棵树只有3个节点，那无论这三个节点里面的数是（1，2，3），还是（2，3，4），或者是（11，12，13）等等，只要是连续的数字，那么他们的二叉搜索树的种类个数就一定是相等的。<code>即树有几种可能性是考虑树中有几个节点，而不是考虑树中节点的实际值。</code></p>
<p>具体来说，考虑n&#x3D;4的情况，在n&#x3D;4时，分为4种情况讨论：</p>
<ul>
<li><p>当root&#x3D;1，那么可以得知对于2，3，4节点来说，这三个节点都将放在以<code>1</code>为根节点的树的右子树下，因为 2，3，4都大于1，那么对于右子树而言，只需要计算（2，3，4）节点的可能种类即<code>d[3]</code>;在考虑左子树，由于没有比1还小的树节点，所以此时的左子树是为空的，即<code>d[0]</code>。一般来说，如果考虑<code>d[0]</code>的实际意义，可能会给<code>d[0]</code>赋值为0;</p>
<p>但是需要考虑到，一棵树的种类，如果确定了根节点，那么这颗树的可能种类就是左子树的可能种类个数乘上右子树的可能种类个数，即<code>d[3]*d[0]</code>，如果我们给<code>d[0]</code>赋值为0，那么<code>d[3]*d[0]==0</code>，这很明显和实际情况不符。再加上题目中<code>1&lt;=n&lt;=19</code>，所以我们不妨将<code>d[0]</code>赋值为<code>1</code>。</p>
</li>
<li><p>那么当roo&#x3D;2，我们同理分析，只有（<code>1</code>）节点(1个节点)在右子树中，而（<code>2,3</code>）节点（2个节点）在左子树中，那么可能性就是<code>d[1]*d[2]</code></p>
</li>
<li><p>同理，当root&#x3D;3，有（<code>1，2</code>）2个节点在右子树，只有（<code>4</code>）1个节点在左子树中，所以可能性是<code>d[2]*d[1]</code></p>
</li>
<li><p>当root&#x3D;4，有(<code>1,2,3</code>)3个节点在右子树，0个节点在左子树，即<code>d[3]*d[0]</code></p>
<p>总结分析得 <code>root==1    d[3]*d[0]</code></p>
<p>总结分析得 <code>root==2    d[2]*d[1]</code></p>
<p>总结分析得 <code>root==3    d[1]*d[2]</code></p>
<p>总结分析得 <code>root==4    d[0]*d[3]</code></p>
<p>​                即 <code>root==j   d[i-j-1]*d[j]</code>，<code>j</code>从<code>0</code>到<code>i-1</code>（0和i-1都去得到）</p>
<p>从实际意义上来理解其实也很好，如果是一颗有<code>i</code>个节点的树，其中一个节点已经确定了是根节点了，所以只有剩下的<code>i-1</code>个节点分别分配在左右子树中，所以左右子树的节点个数相加是<code>i-1</code>，所以上面的<code>d[i-j-1]*d[j]</code>中的<code>i-j-1</code>加上<code>j</code>是一定等于<code>i-1</code>的。</p>
</li>
</ul>
<p>现在只需要对上面的4种情况（<code>i==4</code>种情况)进行求和就可以得出<code>dp[4]</code>即<code>dp[i]</code></p>
<p>这种规律从<code>i=3</code>就开始了，所以可以从<code>i=3</code>开始遍历，一直到题目所求的<code>i==n</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numTrees = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="comment">//d[i]表示有i个节点的二叉搜索树的种数</span></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> cn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            cn += (dp[j] * dp[i-j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = cn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h4><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></p>
<p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,5,11,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以分割成 [1, 5, 5] 和 [11] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,5]</span><br><span class="line">输出：false</span><br><span class="line">解释：数组不能分割成两个元素和相等的子集。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<p><strong>思路</strong></p>
<p>取和不取的问题，对于一个正数数组，数组中所有值的和事确定的，所以分成两个子集后，两个子集的元素和就为整个和的一半</p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode热题hot100</title>
    <url>/2024/05/12/leetcode%E7%83%AD%E9%A2%98hot100/</url>
    <content><![CDATA[<h1 id="leetcode热题hot100【JS】"><a href="#leetcode热题hot100【JS】" class="headerlink" title="leetcode热题hot100【JS】"></a>leetcode热题hot100【JS】</h1><h2 id="更新时间"><a href="#更新时间" class="headerlink" title="更新时间"></a>更新时间</h2><p>2024.5.12 第一次更新</p>
<p>2024.5.17 第二次更新</p>
<h2 id="刷算法题可能用到的函数和表示方式"><a href="#刷算法题可能用到的函数和表示方式" class="headerlink" title="刷算法题可能用到的函数和表示方式"></a>刷算法题可能用到的函数和表示方式</h2><h3 id="常用的表达方式"><a href="#常用的表达方式" class="headerlink" title="常用的表达方式"></a>常用的表达方式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2的10次方</span></span><br><span class="line"><span class="keyword">let</span> n = <span class="number">2</span> ** <span class="number">10</span>;</span><br></pre></td></tr></table></figure>



<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组中插入数据</span></span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//arr = [1]</span></span><br><span class="line">arr.<span class="title function_">indexOf</span>(<span class="number">1</span>);<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//比较两个数组是否相等（只适用于数组里面的元素都是原始值）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arraysAreEqual</span>(<span class="params">array1, array2</span>) &#123;</span><br><span class="line">    <span class="comment">// 首先检查数组长度</span></span><br><span class="line">    <span class="keyword">if</span> (array1.<span class="property">length</span> !== array2.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后检查每个元素是否相等</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array1.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array1[i] !== array2[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果通过了上述检查，那么数组相等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组遍历</span></span><br><span class="line"><span class="keyword">let</span> strs = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strs.<span class="property">length</span>; i++)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i,strs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用for of 与entries()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [i, str] <span class="keyword">of</span> strs.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数字数组的排序</span></span><br><span class="line"><span class="comment">//在JavaScript中，如果sort()方法没有提供比较函数，它会将数组元素转换成字符串，然后按照字符串的Unicode码点顺序进行排序。</span></span><br><span class="line"><span class="comment">//会导致例如这个数组[100,4,200,1,3,2]排序不成功</span></span><br><span class="line"><span class="comment">//例如，数字100和200在转换为字符串后，会根据它们的第一个字符（&quot;1&quot;和&quot;2&quot;）来进行排序，但当比较2和100时，由于&quot;2&quot;的Unicode码点小于&quot;1&quot;的Unicode码点，所以2会排在100之前。</span></span><br><span class="line"><span class="comment">//需要加入比较函数</span></span><br><span class="line">nums = [<span class="number">100</span>,<span class="number">4</span>,<span class="number">200</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>];</span><br><span class="line">nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"><span class="comment">//这个比较函数简单地从a中减去b。如果结果是负数，那么a将排在b之前；如果结果是正数，b将排在a之前；如果结果是0，那么它们的顺序不变。</span></span><br><span class="line"><span class="comment">// a-b就是 从小到大排序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个长度为n，值为0的数组</span></span><br><span class="line"><span class="keyword">let</span> n = <span class="number">5</span>; <span class="comment">// 假设我们想要一个长度为5的数组</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// 输出: [0, 0, 0, 0, 0]</span></span><br></pre></td></tr></table></figure>



<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单个字符转换成ASCII码字</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">ASCIINum</span> = c.<span class="title function_">charCodeAt</span>(<span class="number">0</span>);<span class="comment">//97</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c1 = <span class="string">&#x27;ab&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">ASCIINum</span> = c.<span class="title function_">charCodeAt</span>(<span class="number">2</span>);<span class="comment">//98</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串分割成单个字符的数组</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">char</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(char));</span><br><span class="line"><span class="comment">// [&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串字母排序 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sortString</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="comment">// 将字符串转换为数组</span></span><br><span class="line">    <span class="keyword">let</span> arr = str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="comment">// 对数组进行排序</span></span><br><span class="line">    arr.<span class="title function_">sort</span>();</span><br><span class="line">    <span class="comment">// 将数组转换回字符串</span></span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> originalString = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> sortedString = <span class="title function_">sortString</span>(originalString);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sortedString); <span class="comment">// 输出: ehllo</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>在JavaScript中，<code>Map</code> 是一种新的数据结构，它允许你存储键值对（key-value pairs）。与对象不同，<code>Map</code> 的键可以是任何类型的值，包括函数、对象或任何原始类型。下面是一些基本的 <code>Map</code> 对象用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 `has` 方法可以检查 `Map` 中是否存在某个键：</span></span><br><span class="line"><span class="comment">//创建一个 Map</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置键值对</span></span><br><span class="line"><span class="comment">//使用 `set` 方法可以添加或更新键值对：</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">map.<span class="title function_">set</span>(&#123;&#125;, <span class="string">&#x27;Object&#x27;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;, <span class="string">&#x27;Function&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(<span class="string">&#x27;key&#x27;</span>)); <span class="comment">// 输出: &#x27;value&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(<span class="number">123</span>)); <span class="comment">// 输出: 456</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查键是否存在</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">has</span>(<span class="string">&#x27;key&#x27;</span>)); <span class="comment">// 输出: true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">has</span>(<span class="string">&#x27;notExist&#x27;</span>)); <span class="comment">// 输出: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除键值对</span></span><br><span class="line">map.<span class="title function_">delete</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Map的大小</span></span><br><span class="line"><span class="comment">//使用 `size` 属性可以获取 `Map` 中键值对的数量：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">size</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历Map</span></span><br><span class="line"><span class="comment">//`Map` 对象可以通过 `forEach` 方法遍历，也可以使用迭代器方法（如 `keys()`, `values()`, 和 `entries()`）进行遍历。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 `forEach` 遍历：</span></span><br><span class="line">map.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用迭代器遍历：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者直接遍历Map对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空Map</span></span><br><span class="line">map.<span class="title function_">clear</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>在JavaScript中，<code>Set</code>是一种新的数据结构，它类似于数组，但是它的一个主要特点是其内部的值都是唯一的，没有重复的值。<code>Set</code>对象允许你存储任何类型的唯一值，无论是原始值或是对象引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个 Set</span></span><br><span class="line"><span class="keyword">let</span> mySet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以在创建时初始化`Set`：</span></span><br><span class="line"><span class="keyword">let</span> mySet = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mySet); <span class="comment">// Set(4) &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，即使数组中包含重复的元素，`Set`仍然确保只保存唯一的值。</span></span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">mySet.<span class="title function_">add</span>(<span class="number">5</span>);</span><br><span class="line">mySet.<span class="title function_">add</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">mySet.<span class="title function_">add</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查元素</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mySet.<span class="title function_">has</span>(<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mySet.<span class="title function_">has</span>(<span class="number">6</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">mySet.<span class="title function_">delete</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历 Set</span></span><br><span class="line"><span class="comment">//`Set`对象可以使用`forEach()`方法和`for...of`循环来遍历：</span></span><br><span class="line">mySet.<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> mySet) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 Set 的大小</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mySet.<span class="property">size</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空 Set</span></span><br><span class="line">mySet.<span class="title function_">clear</span>();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Set是JavaScript ES6中引入的一种集合类型，它提供了一种存储唯一值的高效方式。</p>
</blockquote>
<h2 id="100题实战"><a href="#100题实战" class="headerlink" title="100题实战"></a>100题实战</h2><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><h4 id="两数之和【数组、哈希】"><a href="#两数之和【数组、哈希】" class="headerlink" title="两数之和【数组、哈希】"></a>两数之和【数组、哈希】</h4><p><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></p>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
<li><strong>只会存在一个有效答案</strong></li>
</ul>
<p><strong>code</strong>:</p>
<p>第一次写没有考虑到两个数的下标不能一样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> res = [];</span><br><span class="line">        <span class="keyword">let</span> index;</span><br><span class="line">        <span class="keyword">if</span>(( index = nums.<span class="title function_">indexOf</span>(target - nums[i])) != -<span class="number">1</span> &amp;&amp; index != i)&#123;</span><br><span class="line">            res.<span class="title function_">push</span>(i);</span><br><span class="line">            res.<span class="title function_">push</span>(index);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="字母异位词分组【数组、哈希、字符串】"><a href="#字母异位词分组【数组、哈希、字符串】" class="headerlink" title="字母异位词分组【数组、哈希、字符串】"></a>字母异位词分组【数组、哈希、字符串】</h4><p><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></p>
<p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p>
<p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;&quot;]</span><br><span class="line">输出: [[&quot;&quot;]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: strs = [&quot;a&quot;]</span><br><span class="line">输出: [[&quot;a&quot;]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 104</code></li>
<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>
<li><code>strs[i]</code> 仅包含小写字母</li>
</ul>
<p><strong>code</strong></p>
<p>一开始的想法是对每一个字符串的ASCII码求和，和一样的字符串就是字母异位词，但是仔细想一下就知道这样不对，即使字符不一样，也可能会出现SASCII码一样的情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误的</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string[]</span>&#125; <span class="variable">strs</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> groupAnagrams = <span class="keyword">function</span>(<span class="params">strs</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> hash = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strs.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//遍历每一个字符串</span></span><br><span class="line">        <span class="keyword">let</span> sumASCII = <span class="number">0</span>;</span><br><span class="line">        strs[i].<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">c</span> =&gt;</span> sumASCII += c.<span class="title function_">charCodeAt</span>(<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="title function_">has</span>(sumASCII))&#123;<span class="comment">//存在同样的</span></span><br><span class="line">            <span class="keyword">let</span> arr = hash.<span class="title function_">get</span>(sumASCII);</span><br><span class="line">            arr.<span class="title function_">push</span>(strs[i]);</span><br><span class="line">            hash.<span class="title function_">set</span>(sumASCII, arr);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> arr = [];</span><br><span class="line">            arr.<span class="title function_">push</span>(strs[i]);</span><br><span class="line">            hash.<span class="title function_">set</span>(sumASCII,arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    hash.<span class="title function_">forEach</span>( <span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(value);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看了官方解法,有两种解法，排序和计数，很好的解法</p>
<p><strong>排序</strong></p>
<p>思路和上面的ASCII码的思路是一样的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string[]</span>&#125; <span class="variable">strs</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> groupAnagrams = <span class="keyword">function</span>(<span class="params">strs</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> mp = <span class="keyword">new</span> <span class="title class_">Map</span>();<span class="comment">//哈希表，&lt;str, arr&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> [i, str] <span class="keyword">of</span> strs.<span class="title function_">entries</span>())&#123;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">let</span> arr = str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">sort</span>();</span><br><span class="line">        <span class="keyword">let</span> newStr = arr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="title function_">has</span>(newStr))&#123;<span class="comment">//存过了</span></span><br><span class="line">            <span class="keyword">let</span> subArr = mp.<span class="title function_">get</span>(newStr);</span><br><span class="line">            subArr.<span class="title function_">push</span>(str);</span><br><span class="line">            mp.<span class="title function_">set</span>(newStr, subArr);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> subArr = [];</span><br><span class="line">            subArr.<span class="title function_">push</span>(str);</span><br><span class="line">            mp.<span class="title function_">set</span>(newStr, subArr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    mp.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> res.<span class="title function_">push</span>(value));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="【要二刷】最长连续序列【并查集、数组、哈希表】"><a href="#【要二刷】最长连续序列【并查集、数组、哈希表】" class="headerlink" title="【要二刷】最长连续序列【并查集、数组、哈希表】"></a>【要二刷】最长连续序列【并查集、数组、哈希表】</h4><p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></p>
<p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 105</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<p>思路是哈希表，但是刚开始没有想到有负数，通过用例 67&#x2F;75</p>
<p>主要是超过时间限制了，10的9次方的数，遍历一遍就超时了</p>
<p>单出用hashtable[num]++;来计数判断不行了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//个别用例超时</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestConsecutive = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="property">length</span>===<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> maxNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> minNum = <span class="number">0</span>;</span><br><span class="line">    nums.<span class="title function_">map</span>( <span class="function">(<span class="params">v</span>) =&gt;</span>&#123;</span><br><span class="line">        maxNum = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxNum, v);</span><br><span class="line">        minNum = <span class="title class_">Math</span>.<span class="title function_">min</span>(minNum, v);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">let</span> hashTable1 = <span class="title class_">Array</span>(maxNum + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> hashTable2</span><br><span class="line">    <span class="keyword">if</span>(minNum &lt; <span class="number">0</span>)&#123;<span class="comment">//有负数</span></span><br><span class="line">        hashTable2 = <span class="title class_">Array</span>( -<span class="number">1</span> * minNum + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            hashTable1[nums[i]]++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            hashTable2[ -<span class="number">1</span> * nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> maxLen1 = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> maxLen2 = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> l1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> l2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//正数</span></span><br><span class="line">    <span class="keyword">let</span> f1 = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= maxNum ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hashTable1[i] != <span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//有中断</span></span><br><span class="line">            f1 = <span class="literal">true</span>;</span><br><span class="line">            maxLen1 = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLen1, res);</span><br><span class="line">            res = <span class="number">0</span>;<span class="comment">//重新计数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!f1) l1++;</span><br><span class="line">    &#125;</span><br><span class="line">    maxLen1 = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLen1, res);</span><br><span class="line">    <span class="comment">//负数</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> f2 = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= ( -<span class="number">1</span> * minNum) ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hashTable2[i] != <span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//有中断</span></span><br><span class="line">            f2 = <span class="literal">true</span>;</span><br><span class="line">            maxLen2 = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLen2, res);</span><br><span class="line">            res = <span class="number">0</span>;<span class="comment">//重新计数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!f2) l1++;    </span><br><span class="line">    &#125;</span><br><span class="line">    maxLen2 = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLen2, res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算负-0-正</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLen1, maxLen2, l1+l2);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>稍微看了一下题解思路，说是主要判断这个数的上一个数是否在哈希表中，感觉有点思路了，尝试写一下,没写出来，看完题解思路了才写的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestConsecutive = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> mySet = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    nums.<span class="title function_">map</span>( <span class="function"><span class="params">v</span> =&gt;</span> &#123;mySet.<span class="title function_">add</span>(v);&#125;);</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>, cn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//判断该数字是否是连续子串的开头</span></span><br><span class="line">        cn = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!mySet.<span class="title function_">has</span>(nums[i] - <span class="number">1</span>))&#123;<span class="comment">//是开头</span></span><br><span class="line">            <span class="keyword">let</span> st = nums[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(mySet.<span class="title function_">has</span>(st))&#123;</span><br><span class="line">                cn++;</span><br><span class="line">                st++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="title class_">Math</span>.<span class="title function_">max</span>(res, cn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="移动零【数组、双指针】"><a href="#移动零【数组、双指针】" class="headerlink" title="移动零【数组、双指针】"></a>移动零【数组、双指针】</h4><p><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></p>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure>

<p><strong>提示</strong>:</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
</ul>
<p><strong>进阶：</strong>你能尽量减少完成的操作次数吗？</p>
<p><strong>code</strong></p>
<p>快慢指针的思路</p>
<p>慢指针指向待更新的数</p>
<p>快指针指向非0需要转移的数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> moveZeroes = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="comment">// 0 1 0 3 12</span></span><br><span class="line">    <span class="comment">//在 0 的位置对非 0 赋值</span></span><br><span class="line">    <span class="keyword">let</span> len = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> f = <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(s = <span class="number">0</span>; s &lt; len; s++)&#123;</span><br><span class="line">        <span class="keyword">while</span>( f &lt; len &amp;&amp; nums[f] == <span class="number">0</span>) f++;</span><br><span class="line">        <span class="keyword">if</span>(f &gt;= len) <span class="keyword">break</span>;</span><br><span class="line">        nums[s] = nums[f++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(s&lt;len)&#123;</span><br><span class="line">        nums[s++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="盛最多水的容器【双指针、贪心】"><a href="#盛最多水的容器【双指针、贪心】" class="headerlink" title="盛最多水的容器【双指针、贪心】"></a>盛最多水的容器【双指针、贪心】</h4><p><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></p>
<p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p><strong>说明：</strong>你不能倾斜容器。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == height.length</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= height[i] &lt;= 104</code></li>
</ul>
<p><strong>code</strong>：</p>
<p>前几天刚做过，复习了一下</p>
<p>双指针，两边夹</p>
<p>贪心的想法，由于装水的面积是右桶的长短决定的，所以较短的那条边先向中间走（这是保证从长到短的宽度下的最优解）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">height</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxArea = <span class="keyword">function</span>(<span class="params">height</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxNum = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> st = <span class="number">0</span>, end = height.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(st &lt; end)&#123;</span><br><span class="line">        maxNum = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxNum, (end - st) * <span class="title class_">Math</span>.<span class="title function_">min</span>(height[st], height[end]));</span><br><span class="line">        <span class="keyword">if</span>(height[st] &lt;= height[end])&#123;</span><br><span class="line">            st++;</span><br><span class="line">        &#125;<span class="keyword">else</span> end--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxNum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="【优先二刷】三数之和-【数组，双指针】"><a href="#【优先二刷】三数之和-【数组，双指针】" class="headerlink" title="【优先二刷】三数之和 【数组，双指针】"></a>【优先二刷】三数之和 【数组，双指针】</h4><p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></p>
<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p>
<p>你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<p><strong>code：</strong></p>
<p>排序去重是一个很重要的点，有很多题目，都是组成元素一样，但是顺序不一样，此时，应该考虑排序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> j = i; j &lt; nums.<span class="property">length</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( i != j)&#123;</span><br><span class="line">                <span class="keyword">let</span> sum = nums[i] + nums[j];</span><br><span class="line">                <span class="keyword">let</span> index = nums.<span class="title function_">indexOf</span>(-sum);</span><br><span class="line">                <span class="keyword">if</span>(index != -<span class="number">1</span> &amp;&amp; index != i &amp;&amp; index != j)&#123; </span><br><span class="line">                    <span class="keyword">let</span> arr = []; </span><br><span class="line">                    arr.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">                    arr.<span class="title function_">push</span>(nums[index]);</span><br><span class="line">                    arr.<span class="title function_">push</span>(nums[j]);              </span><br><span class="line">                    arr.<span class="title function_">sort</span>();</span><br><span class="line">                    <span class="keyword">if</span>(!set.<span class="title function_">has</span>(arr))&#123;</span><br><span class="line">                        res.<span class="title function_">push</span>(arr);</span><br><span class="line">                        set.<span class="title function_">add</span>(arr);</span><br><span class="line">                    &#125;     </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是这样写的话在JS中是不能用set去重的，因为set中的元素是对象，对象引用的是指针，就算排序后的数组中的每一个元素都是一样的，set也会认为这是不同的数组。然后尝试将数组使用join函数转换为字符串在传入set去重</p>
<p>但是还是有问题，测试用例过227&#x2F;313，不知道哪里错了，看不出来.</p>
<p>还有效率问题：您的代码使用了三层循环（实际上是两层循环加一个线性搜索 indexOf），这导致时间复杂度高达 O(n^3)，在 nums 数组较大时会非常低效。</p>
<p>思考：其实经常想不到sort排序的解法，应该想到的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> j = i; j &lt; nums.<span class="property">length</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( i != j)&#123;</span><br><span class="line">                <span class="keyword">let</span> sum = nums[i] + nums[j];</span><br><span class="line">                <span class="keyword">let</span> index = nums.<span class="title function_">indexOf</span>(-sum);</span><br><span class="line">                <span class="keyword">if</span>(index != -<span class="number">1</span> &amp;&amp; index != i &amp;&amp; index != j)&#123; </span><br><span class="line">                    <span class="keyword">let</span> arr = []; </span><br><span class="line">                    arr.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">                    arr.<span class="title function_">push</span>(nums[index]);</span><br><span class="line">                    arr.<span class="title function_">push</span>(nums[j]);              </span><br><span class="line">                    arr.<span class="title function_">sort</span>();</span><br><span class="line">                    <span class="keyword">let</span> str = arr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">                    <span class="keyword">if</span>(!set.<span class="title function_">has</span>(str))&#123;</span><br><span class="line">                        res.<span class="title function_">push</span>(arr);</span><br><span class="line">                        set.<span class="title function_">add</span>(str);</span><br><span class="line">                    &#125;     </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>转换思路，咨询了一下AI模型，跑了后还是对的</p>
<p>排序：首先对数组进行排序，这样可以更容易地避免重复的三元组，并且可以使用双指针技术来减少不必要的搜索。</p>
<p>双指针：使用一个外层循环遍历每个元素，然后在剩余部分使用两个指针（一个从左边开始，另一个从右边开始）来寻找两个数，使得这三个数的和为0。</p>
<p>跳过重复元素：在外层循环和双指针移动时，如果遇到相同的元素，应该跳过，以避免重复的三元组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="comment">//排序+循环嵌套双指针（两边夹）</span></span><br><span class="line">    <span class="comment">//因为有重复元素，还要去重</span></span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a - b);<span class="comment">//递增</span></span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">2</span>; i++)&#123;<span class="comment">//-2时因为i是三元组的第一个，要构成三元组就不可能是最后一个</span></span><br><span class="line">        <span class="comment">//对于三元组中的第一个数，也要去重，同一个数，只操作一次</span></span><br><span class="line">        <span class="keyword">if</span>( i &gt; <span class="number">0</span>  &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//if( i + 1 &lt; nums.length - 2 &amp;&amp; nums[i + 1] == nums[i]) continue;这样的去重逻辑是错误的，不要这样写</span></span><br><span class="line">        <span class="comment">//双指针两边夹</span></span><br><span class="line">        <span class="keyword">let</span> left = i + <span class="number">1</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">let</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span>(sum === <span class="number">0</span>)&#123;<span class="comment">//找到一个三元组</span></span><br><span class="line">                res.<span class="title function_">push</span>([nums[i], nums[right], nums[left]]);</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="【！！dp，还没写】接雨水"><a href="#【！！dp，还没写】接雨水" class="headerlink" title="【！！dp，还没写】接雨水"></a>【！！dp，还没写】接雨水</h4><p><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></p>
<p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [4,2,0,3,2,5]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == height.length</code></li>
<li><code>1 &lt;= n &lt;= 2 * 104</code></li>
<li><code>0 &lt;= height[i] &lt;= 105</code></li>
</ul>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h4 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h4><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></p>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<p><strong>code:</strong></p>
<p>不用map，用set和单纯数组都行，数组的话就用include方法来查看字母是否已经存在于数组中，但是最好还是不要数组了，数组里面删除一个元素会很麻烦，主要还是哈希+滑动窗口的思想。</p>
<p>用set的话会简单一点点</p>
<p>带注释版本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//无重复字符的最长子串</span></span><br><span class="line">    <span class="comment">//ex</span></span><br><span class="line">    <span class="comment">// abcabcbb</span></span><br><span class="line">    <span class="comment">// abc -&gt; maxLen = 3</span></span><br><span class="line">    <span class="comment">//滑动窗口</span></span><br><span class="line">    <span class="comment">//1.定义需要维护的变量</span></span><br><span class="line">    <span class="keyword">let</span> maxLen = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> hash = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="comment">//2.定义窗口的首尾端，然后滑动窗口</span></span><br><span class="line">    <span class="keyword">let</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> end = <span class="number">0</span>; end &lt; s.<span class="property">length</span>; end++)&#123;<span class="comment">//第一次debug是end++写成s++了</span></span><br><span class="line">        <span class="comment">//维护变量</span></span><br><span class="line">        <span class="keyword">let</span> c = s[end];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//情况2:窗口可变,检查窗口是否合法，不合法就调整st指针直至合法  </span></span><br><span class="line">        <span class="comment">//在该题目中，不合法指的是，字符串中出现重复字符 </span></span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="title function_">has</span>(c))&#123;<span class="comment">//c字符不是第一次出现，窗口不合法</span></span><br><span class="line">            <span class="comment">//只要连续移动字符，直到新的窗口的字符中不包含第一次出现的c字符位置</span></span><br><span class="line">            <span class="keyword">while</span>( st &lt; end &amp;&amp; s[st] != c)&#123;</span><br><span class="line">                hash.<span class="title function_">delete</span>(s[st]);<span class="comment">//第二次debug，这一句和下面一句的顺序反了，如果先++在delet，那么相当于delet的是下一个字符，第一个字符永远都不会被移除</span></span><br><span class="line">                st++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//此时的st应该位于第一个窗口的第一个c字符处</span></span><br><span class="line">            st++;</span><br><span class="line">            <span class="comment">//现在窗口合法了</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//第一次出现</span></span><br><span class="line">            hash.<span class="title function_">set</span>(c, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//窗口的长度为end - st + 1 （左闭右闭区间）</span></span><br><span class="line">        <span class="comment">//如果是左闭右开区间，就是end - st</span></span><br><span class="line">        maxLen = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLen, end - st + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不带注释</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> maxLen = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> hash = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> end = <span class="number">0</span>; end &lt; s.<span class="property">length</span>; end++)&#123;</span><br><span class="line">        <span class="keyword">let</span> c = s[end];    </span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">            <span class="keyword">while</span>( st &lt; end &amp;&amp; s[st] != c)&#123;</span><br><span class="line">                hash.<span class="title function_">delete</span>(s[st]);</span><br><span class="line">                st++;</span><br><span class="line">            &#125; </span><br><span class="line">            st++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            hash.<span class="title function_">set</span>(c, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen = <span class="title class_">Math</span>.<span class="title function_">max</span>(maxLen, end - st + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h4><p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></p>
<p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p><strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</span><br><span class="line">输出: [0,6]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。</span><br></pre></td></tr></table></figure>

<p> <strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;, p = &quot;ab&quot;</span><br><span class="line">输出: [0,1,2]</span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。</span><br><span class="line">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。</span><br></pre></td></tr></table></figure>

<p><strong>Code:</strong></p>
<p>窗口不合理的情况比较复杂</p>
<p>带注释版本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">p</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findAnagrams = <span class="keyword">function</span>(<span class="params">s, p</span>) &#123;</span><br><span class="line">    <span class="comment">//哈希(异位词)+滑动窗口(子串)</span></span><br><span class="line">    <span class="comment">//异位词的特点是：</span></span><br><span class="line">    <span class="comment">//1.长度相等</span></span><br><span class="line">    <span class="comment">//2.每个字符的出现次数相等</span></span><br><span class="line">    <span class="keyword">let</span> hash = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> hash2 = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="comment">//初始化hash</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; p.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="title function_">has</span>(p[i]))&#123;</span><br><span class="line">            hash.<span class="title function_">set</span>(p[i], hash.<span class="title function_">get</span>(p[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> hash.<span class="title function_">set</span>(p[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化窗口，并开始滑动</span></span><br><span class="line">    <span class="keyword">let</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> end = <span class="number">0</span>; end &lt; s.<span class="property">length</span>; end++)&#123;</span><br><span class="line">        <span class="keyword">let</span> c = s[end];</span><br><span class="line">        <span class="keyword">if</span>(hash2.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">            hash2.<span class="title function_">set</span>(c, hash2.<span class="title function_">get</span>(c) + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> hash2.<span class="title function_">set</span>(c, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//窗口不合法1，没有这个字符,两个指针都跳到这个指针后面</span></span><br><span class="line">        <span class="keyword">if</span>(!hash.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">            <span class="keyword">while</span>(st != end + <span class="number">1</span>)&#123;<span class="comment">//debug1,一开始没有跳转到st = end+1，只是st++，这样是不对的，而且跳转完之后，一定要记得移除hash2中前面的（已经不在滑动窗口中的）字母</span></span><br><span class="line">                hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);</span><br><span class="line">                st++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(hash2.<span class="title function_">get</span>(c) &gt; hash.<span class="title function_">get</span>(c))&#123;</span><br><span class="line">            <span class="comment">//窗口不合法2,有这个字符，但是字符数多了,移动st，直到窗口中的c的字符数与hash中的字符数一致</span></span><br><span class="line">            <span class="keyword">while</span>(hash2.<span class="title function_">get</span>(c) != hash.<span class="title function_">get</span>(c))&#123;</span><br><span class="line">                hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);</span><br><span class="line">                st++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//窗口不合法3，窗口长度超过了</span></span><br><span class="line">        <span class="keyword">while</span>(end - st + <span class="number">1</span> &gt; p.<span class="property">length</span>)&#123;</span><br><span class="line">            hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);<span class="comment">//debug2，滑动了窗口，但是忘记处理hash2了</span></span><br><span class="line">            st++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(end - st + <span class="number">1</span> === p.<span class="property">length</span>)&#123;</span><br><span class="line">            res.<span class="title function_">push</span>(st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不带注释版本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">p</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findAnagrams = <span class="keyword">function</span>(<span class="params">s, p</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> hash = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> hash2 = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; p.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.<span class="title function_">has</span>(p[i]))&#123;</span><br><span class="line">            hash.<span class="title function_">set</span>(p[i], hash.<span class="title function_">get</span>(p[i]) + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> hash.<span class="title function_">set</span>(p[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> end = <span class="number">0</span>; end &lt; s.<span class="property">length</span>; end++)&#123;</span><br><span class="line">        <span class="keyword">let</span> c = s[end];</span><br><span class="line">        <span class="keyword">if</span>(hash2.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">            hash2.<span class="title function_">set</span>(c, hash2.<span class="title function_">get</span>(c) + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> hash2.<span class="title function_">set</span>(c, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!hash.<span class="title function_">has</span>(c))&#123;</span><br><span class="line">            <span class="keyword">while</span>(st != end + <span class="number">1</span>)&#123;</span><br><span class="line">                hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);</span><br><span class="line">                st++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(hash2.<span class="title function_">get</span>(c) &gt; hash.<span class="title function_">get</span>(c))&#123;</span><br><span class="line">            <span class="keyword">while</span>(hash2.<span class="title function_">get</span>(c) != hash.<span class="title function_">get</span>(c))&#123;</span><br><span class="line">                hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);</span><br><span class="line">                st++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(end - st + <span class="number">1</span> &gt; p.<span class="property">length</span>)&#123;</span><br><span class="line">            hash2.<span class="title function_">set</span>(s[st], hash2.<span class="title function_">get</span>(s[st]) - <span class="number">1</span>);</span><br><span class="line">            st++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(end - st + <span class="number">1</span> === p.<span class="property">length</span>)&#123;</span><br><span class="line">            res.<span class="title function_">push</span>(st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><h4 id="【优先二刷】和为-K-的子数组"><a href="#【优先二刷】和为-K-的子数组" class="headerlink" title="【优先二刷】和为 K 的子数组"></a>【优先二刷】和为 K 的子数组</h4><p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></p>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p>
<p>子数组是数组中元素的连续非空序列。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1], k = 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3], k = 3</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>code:</strong></p>
<p>一刷本来想用滑动窗口做，但是发现有负数，没法用滑动窗口做。</p>
<p>这个问题可以通过使用“前缀和”加上“哈希表”来高效解决。基本思路是，我们遍历数组，计算每个位置的前缀和，即从数组开始到当前元素的累计和。然后，对于每个前缀和，我们检查是否存在一个之前的前缀和，其值等于“当前前缀和 - k”。如果存在，这意味着这两个前缀和之间的元素的和正好为k。我们使用哈希表来存储每个前缀和出现的次数，这样就可以在O(1)时间内查找到之前的前缀和。</p>
<p>在这道题学会了<code>前缀和</code>的用法，这确实是我比较少用的一个点</p>
<p>学习了：</p>
<ul>
<li><p>前缀和的思想</p>
</li>
<li><p>用对象来构建哈希表</p>
</li>
<li><p>let of的用法，</p>
<ul>
<li><p>let of访问的是value</p>
</li>
<li><p>let in访问的是索引号</p>
</li>
<li><p>如果想同时访问value和index可以用for循环或者<code>nums.forEach((value, index) =&gt; &#123;console.log(1);&#125;);</code></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>forEach()</code>方法在遍历数组时访问的是原数组。这意味着在<code>forEach()</code>循环中，您可以直接访问并操作原数组的元素。</p>
<p><code>forEach()</code>里面的回调函数确实可以修改原数组的元素。但是，需要注意的是，虽然您可以修改数组的元素，比如通过索引更改元素的值，您却不能通过<code>forEach()</code>直接修改数组的结构，例如增加或删除元素，对数组结构的修改不会影响到遍历过程。这是因为<code>forEach()</code>遍历的范围在第一次调用回调函数之前就已经确定了。</p>
<p>下面是一个示例，展示了如何通过<code>forEach()</code>修改原数组的元素：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 forEach() 修改数组元素的值</span></span><br><span class="line">nums.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 将每个元素值加倍</span></span><br><span class="line">    array[index] = value * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nums); <span class="comment">// 输出: [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们通过<code>forEach()</code>遍历数组，并将每个元素的值加倍。虽然我们在<code>forEach()</code>的回调函数中直接修改了数组元素的值，但是请注意，如果尝试在遍历过程中添加或删除元素，可能不会影响当前的遍历过程，因为遍历的范围是在遍历开始前就已经确定了。</p>
</blockquote>
<p>由此可见，这是一个数学题TAT，思路如下：</p>
<p>a1 a2 a3 a4 a5 a6<br>cn1 &#x3D; a1 + a2<br>cn2 &#x3D; a1 + a2 + a3 + a4</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//如果 a3 + a4 = k =&gt;有一个子串和位k</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> subarraySum = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pre_sum_hash = &#123;<span class="number">0</span> : <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> num <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        sum += num;</span><br><span class="line">        <span class="comment">// sum - otherPreSum = k =&gt; sum - k = otherPreSum </span></span><br><span class="line">        <span class="keyword">let</span> otherPreSum = sum - k;</span><br><span class="line">        <span class="keyword">if</span>(pre_sum_hash[otherPreSum] !== <span class="literal">undefined</span>)&#123;</span><br><span class="line">            res += pre_sum_hash[otherPreSum];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新哈希表</span></span><br><span class="line">        <span class="keyword">if</span>(pre_sum_hash[sum] !== <span class="literal">undefined</span>)&#123;</span><br><span class="line">            pre_sum_hash[sum]++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre_sum_hash[sum] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>算法</tag>
        <tag>leetcod</tag>
      </tags>
  </entry>
  <entry>
    <title>《JavaScript权威指南》读书笔记第七章函数表达式</title>
    <url>/2024/05/11/%E3%80%8AjavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="第七章——函数表达式"><a href="#第七章——函数表达式" class="headerlink" title="第七章——函数表达式"></a>第七章——函数表达式</h1><h2 id="函数表达式的特征"><a href="#函数表达式的特征" class="headerlink" title="函数表达式的特征"></a>函数表达式的特征</h2><p>定义函数的两种方法：</p>
<ul>
<li><p>函数声明</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params">arg0, arg1, arg2</span>)&#123;</span><br><span class="line">  <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有一些浏览器给函数定义了一个name属性，可以通过这个属性访问到给函数指定的名字，这个值为function关键字后面的标识符。</p>
<p>alert(function.name);&#x2F;&#x2F;“funtionName”</p>
</blockquote>
</li>
<li><p>函数表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>两个定义函数的方法的异同：</p>
<p>由函数声明的函数在JS脚本构建时，会<code>函数提升</code>，而由函数表达式定义的函数不会。</p>
<h2 id="使用函数实现递归"><a href="#使用函数实现递归" class="headerlink" title="使用函数实现递归"></a>使用函数实现递归</h2><h2 id="使用闭包定义私有变量"><a href="#使用闭包定义私有变量" class="headerlink" title="使用闭包定义私有变量"></a>使用闭包定义私有变量</h2>]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针：两个输入,两个都需要遍历（快慢指针）</title>
    <url>/2024/05/10/%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%9A%E4%B8%A4%E4%B8%AA%E8%BE%93%E5%85%A5-%E4%B8%A4%E4%B8%AA%E9%83%BD%E9%9C%80%E8%A6%81%E9%81%8D%E5%8E%86%EF%BC%88%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%EF%BC%89/</url>
    <content><![CDATA[<h3 id="2-双指针：两个输入-两个都需要遍历（快慢指针）"><a href="#2-双指针：两个输入-两个都需要遍历（快慢指针）" class="headerlink" title="2.双指针：两个输入,两个都需要遍历（快慢指针）"></a>2.双指针：两个输入,两个都需要遍历（快慢指针）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params">arr1, arr2</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(i &lt; arr1.<span class="property">length</span> &amp;&amp; j &lt; arr2.<span class="property">length</span>)&#123;</span><br><span class="line">    <span class="comment">//根据题意补充代码</span></span><br><span class="line">    <span class="keyword">if</span>()&#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; arr1.<span class="property">length</span>)&#123;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; arr2.<span class="property">length</span>)&#123;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><a href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组</a></p>
<p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p>
<p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p>
<p><strong>注意：</strong>最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br><span class="line">解释：需要合并 [1,2,3] 和 [2,5,6] 。</span><br><span class="line">合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1], m = 1, nums2 = [], n = 0</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并 [1] 和 [] 。</span><br><span class="line">合并结果是 [1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [0], m = 0, nums2 = [1], n = 1</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并的数组是 [] 和 [1] 。</span><br><span class="line">合并结果是 [1] 。</span><br><span class="line">注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</span><br></pre></td></tr></table></figure>

<p>思路一：双指针，但是不借助额外的数组，原数组nums1的值就会被覆盖，但是题目没有说不能借助额外数组，所以就先放到新的数组里面，在把新数组赋值给nuns1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">m</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//思路一：双指针，但是不借助额外的数组，原数组nums1的值就会被覆盖，但是题目没有说不能借助额外数组，所以就先放到新的数组里面，在把新数组赋值给nuns1</span></span><br><span class="line">    <span class="keyword">let</span> newArr = <span class="keyword">new</span> <span class="title class_">Array</span>(m + n);</span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; m &amp;&amp; j &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums2[j] &lt;= nums1[i])&#123;</span><br><span class="line">            newArr[k++] = nums2[j++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            newArr[k++] = nums1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; m) newArr[k++] = nums1[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n) newArr[k++] = nums2[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> p = <span class="number">0</span>; p &lt; m + n; p++)&#123;</span><br><span class="line">        nums1[p] = newArr[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>思路二：逆向双指针，因为num1的数组的末尾m个都是0，是不害怕被覆盖的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">m</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>, k = m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[i] &gt;= nums2[j])&#123;</span><br><span class="line">            nums1[k--] = nums1[i--];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            nums1[k--] = nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span>) nums1[k--] = nums1[i--];</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span>) nums1[k--] = nums2[j--];</span><br><span class="line">    <span class="keyword">return</span> nums1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针：一个输入，两端遍历（两边夹）</title>
    <url>/2024/05/10/%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%9A%E4%B8%80%E4%B8%AA%E8%BE%93%E5%85%A5%EF%BC%8C%E4%B8%A4%E7%AB%AF%E9%81%8D%E5%8E%86%EF%BC%88%E4%B8%A4%E8%BE%B9%E5%A4%B9%EF%BC%89/</url>
    <content><![CDATA[<h3 id="双指针：一个输入，两端遍历（两边夹）"><a href="#双指针：一个输入，两端遍历（两边夹）" class="headerlink" title="双指针：一个输入，两端遍历（两边夹）"></a>双指针：一个输入，两端遍历（两边夹）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//箭头函数 ()=&gt;&#123;&#125;</span></span><br><span class="line"><span class="comment">//()表示参数</span></span><br><span class="line"><span class="comment">//&#123;&#125;表示函数体</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">fn</span> = arr =&gt;&#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>, ans = <span class="number">0</span>, right = arr.<span class="property">length</span> -<span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">    <span class="comment">//根据题意补充代码</span></span><br><span class="line">    <span class="keyword">if</span>()&#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      right--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></p>
<p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p><strong>说明：</strong>你不能倾斜容器。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1 </span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == height.length</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= height[i] &lt;= 104</code></li>
</ul>
<p>做题思路：</p>
<p>双指针</p>
<p>长*宽的最大值，迭代</p>
<p>难点在于在什么情况下移动左指针，在什么情况下移动右指针</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">height</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxArea = <span class="keyword">function</span>(<span class="params">height</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = height.<span class="property">length</span> - <span class="number">1</span>, maxAns = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">let</span> w = right - left;</span><br><span class="line">        <span class="keyword">let</span> h = <span class="title class_">Math</span>.<span class="title function_">min</span>(height[left], height[right]);</span><br><span class="line">        maxAns = <span class="title class_">Math</span>.<span class="title function_">max</span>(w * h, maxAns);</span><br><span class="line">        <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxAns</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参考官方题解</p>
<p><a href="https://leetcode.cn/problems/container-with-most-water/solutions/207215/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution">https://leetcode.cn/problems/container-with-most-water/solutions/207215/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vue】v-bind</title>
    <url>/2024/04/24/%E3%80%90Vue%E3%80%91v-bind/</url>
    <content><![CDATA[<h1 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h1><p> 是Vue.js中的一个指令，用于动态地绑定一个或多个属性，或者传递属性到组件。它可以将数据的值绑定到HTML元素的属性上，或者是父组件向子组件传递数据。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul>
<li><strong>绑定HTML属性</strong>：可以将数据绑定到元素的属性上。例如，如果你想根据数据动态改变<img>的src属性，可以这样写：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&lt;img v-<span class="attr">bind</span>:src=<span class="string">&quot;imageSrc&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>这里，imageSrc是一个变量名，它的值会被设置为img的src属性。</p>
<ul>
<li><strong>缩写</strong>：v-bind:有一个缩写，即冒号:。上面的例子可以简写为：</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&lt;img :src=<span class="string">&quot;imageSrc&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="绑定多个属性"><a href="#绑定多个属性" class="headerlink" title="绑定多个属性"></a>绑定多个属性</h3><p>v-bind也可以通过使用对象语法一次绑定多个属性。例如：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind=<span class="string">&quot;&#123; id: someId, &#x27;data-name&#x27;: name &#125;&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>这里，someId和name是变量，它们的值将分别绑定到div的id属性和data-name属性。</p>
<h3 id="绑定到组件的props"><a href="#绑定到组件的props" class="headerlink" title="绑定到组件的props"></a>绑定到组件的props</h3><p>当使用组件时，v-bind用于将数据从父组件传递到子组件的props：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&lt;my-component :some-prop=<span class="string">&quot;someData&quot;</span>&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>

<p>这里，someData是父组件中的数据，some-prop是子组件的prop，someData的值将传递给子组件的some-prop。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>动态绑定元素的类和样式。</p>
<p>将数据传递给组件的props。</p>
<p>根据数据动态改变元素的属性，如src、href等。</p>
<p>v-bind:是Vue开发中非常常用的一个指令，它提高了代码的灵活性和可维护性，使得数据和视图之间的绑定更加直观和方便。</p>
<blockquote>
<p>V-bind可以绑定变量、绑定类、绑定属性等等</p>
</blockquote>
]]></content>
      <tags>
        <tag>Vue3</tag>
        <tag>Vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>鉴权失败</title>
    <url>/2024/04/24/%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<h3 id="【git部署时输入密码错误】remote-Support-for-password-authentication-was-removed-on-August-13-2021-remote-Please-see-https-docs-github-com-get-started-getting-started-with-git-about-remote-repositories-cloning-with-https-urls-for-information-on-currently-recommended-modes-of-authentication-致命错误：’https-github-com-SHIFFF-SHIFFF-github-io-git-‘-鉴权失败"><a href="#【git部署时输入密码错误】remote-Support-for-password-authentication-was-removed-on-August-13-2021-remote-Please-see-https-docs-github-com-get-started-getting-started-with-git-about-remote-repositories-cloning-with-https-urls-for-information-on-currently-recommended-modes-of-authentication-致命错误：’https-github-com-SHIFFF-SHIFFF-github-io-git-‘-鉴权失败" class="headerlink" title="【git部署时输入密码错误】remote: Support for password authentication was removed on August 13, 2021. remote: Please see https://docs.github.com/get-started/getting-started-with-git/about-remote-repositories#cloning-with-https-urls for information on currently recommended modes of authentication. 致命错误：’https://github.com/SHIFFF/SHIFFF.github.io.git/‘ 鉴权失败"></a>【git部署时输入密码错误】remote: Support for password authentication was removed on August 13, 2021. remote: Please see <a href="https://docs.github.com/get-started/getting-started-with-git/about-remote-repositories#cloning-with-https-urls">https://docs.github.com/get-started/getting-started-with-git/about-remote-repositories#cloning-with-https-urls</a> for information on currently recommended modes of authentication. 致命错误：’<a href="https://github.com/SHIFFF/SHIFFF.github.io.git/">https://github.com/SHIFFF/SHIFFF.github.io.git/</a>‘ 鉴权失败</h3><p>GitHub于2021年8月13日移除了对密码身份验证的支持，因此您需要使用其他身份验证方式来访问GitHub仓库。</p>
<p>推荐的替代方式是使用个人访问令牌（Personal Access Token）作为身份验证凭据。您可以在GitHub上生成一个个人访问令牌，并将其用作密码来访问您的仓库。</p>
<p>以下是解决此问题的一般步骤：</p>
<ol>
<li><p>在GitHub上生成个人访问令牌：</p>
<ul>
<li>登录GitHub账号，转到Settings -&gt; Developer settings -&gt; Personal access tokens。</li>
<li>点击Generate new token，选择所需的权限，并生成访问令牌。</li>
<li>复制生成的访问令牌。</li>
</ul>
</li>
<li><p>在Git中使用个人访问令牌：</p>
<ul>
<li>当Git提示输入用户名和密码时，用户名为您的GitHub用户名，密码为您生成的个人访问令牌。</li>
</ul>
</li>
</ol>
<p>通过这种方式，您应该能够成功进行身份验证并访问您的GitHub仓库。如果问题仍然存在，请参考提供的链接以获取更多信息或尝试其他解决方案。</p>
]]></content>
      <tags>
        <tag>git</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title>【Vue3】withDefaults和defineProps</title>
    <url>/2024/04/24/%E3%80%90Vue3%E3%80%91withDefaults%E5%92%8CdefineProps/</url>
    <content><![CDATA[<p>在Vue 3中，withDefaults和defineProps是用于定义和设置组件的props的工具，特别是在使用script setup语法糖时。</p>
<h3 id="defineProps"><a href="#defineProps" class="headerlink" title="defineProps"></a>defineProps</h3><p>defineProps函数用于在Vue组件中声明props的类型。它通常与TypeScript一起使用，以提供类型安全。在script setup语法中，defineProps用于定义接收自父组件的数据的属性。</p>
<h3 id="withDefaults"><a href="#withDefaults" class="headerlink" title="withDefaults"></a>withDefaults</h3><p>withDefaults函数在Vue 3中用于为defineProps定义的props提供默认值。它的参数结构如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">withDefaults</span>(defineProps&lt;<span class="title class_">Type</span>&gt;(), defaultProps)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一个参数是defineProps调用的结果，defineProps<Type>()用于定义组件的props，并且可以指定一个TypeScript接口或类型来静态类型检查这些props。</p>
</li>
<li><p>第二个参数是一个对象，其中的键是prop的名字，值是这个prop的默认值。默认值可以是直接的值，或者是返回值的函数，这样每次使用默认值时都会调用该函数来获取一个新的值。</p>
</li>
</ul>
<p>例如</p>
<p>withDefaults函数用于为defineProps定义的props提供默认值。这是处理props可能未被父组件传递时的情况的一种方式，确保组件有一个可靠的默认状态。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineProps, withDefaults &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Props</span> &#123;</span><br><span class="line">  <span class="attr">postList</span>: <span class="built_in">any</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> props = <span class="title function_">withDefaults</span>(defineProps&lt;<span class="title class_">Props</span>&gt;(),&#123;</span><br><span class="line">  <span class="attr">postList</span>: <span class="function">() =&gt;</span> [],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>defineProps<Props>()：这里使用Props接口来定义props的结构，Props接口指定了postList是一个数组。</p>
</li>
<li><p>withDefaults(…, { postList: () &#x3D;&gt; [] })：这里为postList提供了一个默认值。默认值是通过一个函数() &#x3D;&gt; []来指定的，这意味着如果没有提供postList，它将默认为一个空数组。使用函数来返回默认值是一种常见的做法，因为这确保了每次使用默认值时都会创建一个新的数组实例，避免了不同实例间共享同一个数组的问题。</p>
</li>
</ul>
<h3 id="postList-x3D-gt-的意思"><a href="#postList-x3D-gt-的意思" class="headerlink" title="postList: () &#x3D;&gt; []的意思"></a>postList: () &#x3D;&gt; []的意思</h3><p>这里postList: () &#x3D;&gt; []表示postList的默认值是一个空数组。使用箭头函数()返回一个新的空数组[]，这样做的好处是每次调用这个默认值时都会创建一个新的数组实例，避免了潜在的引用类型数据共享问题，这是在JavaScript中处理数组和对象默认值的推荐做法。</p>
<p>总结来说，这种写法确保了组件的postList prop在没有从父组件接收到值时，会安全地使用一个新的空数组作为默认值，同时保持了类型安全和响应性。</p>
]]></content>
      <tags>
        <tag>Vue3</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【哈希+map】2404.出现最频繁的偶数元素</title>
    <url>/2023/04/13/%E5%87%BA%E7%8E%B0%E6%9C%80%E9%A2%91%E7%B9%81%E7%9A%84%E5%81%B6%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="【哈希-map】2404-出现最频繁的偶数元素"><a href="#【哈希-map】2404-出现最频繁的偶数元素" class="headerlink" title="【哈希+map】2404. 出现最频繁的偶数元素"></a>【哈希+map】2404. 出现最频繁的偶数元素</h2><blockquote>
<p> Problem: <a href="https://leetcode.cn/problems/most-frequent-even-element/description/">2404. 出现最频繁的偶数元素</a></p>
</blockquote>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>从数组中找出出现次数最多的偶数（如果这样的数有多个，选取较小的那个）</p>
<h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>原本的想法是使用map+set，map当作哈希表用来计数，set来记录出现次数最多的偶数，(看了大佬的代码)后来优化了只用map，使用int变量res记录出现次数最多的偶数，如果出现次数一样多，且这个数较小，则更新res。</p>
<p>顺便复习了下C++中map和set的用法，这两个都只能通过使用迭代器遍历，但是map可以通过map[key]的方式来访问和赋值，可使用的函数用<code>begin()</code>、<code>end()</code>、<code>find()</code>、<code>clear()</code>等等。</p>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul>
<li><p>时间复杂度: </p>
<blockquote>
<p>$O(n)$</p>
</blockquote>
</li>
<li><p>空间复杂度: </p>
<blockquote>
<p>$O(n)$</p>
</blockquote>
</li>
</ul>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>原版:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">原版</span></span><br><span class="line"><span class="comment">从数组中找出出现次数最多的偶数（如果这样的数有多个，选取较小的那个）</span></span><br><span class="line"><span class="comment">***/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mostFrequentEven</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录偶数出现的次数,存在mp中</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp.<span class="built_in">find</span>(num)==mp.<span class="built_in">end</span>())&#123;<span class="comment">//找不到</span></span><br><span class="line">                    mp[num] = <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    mp[num]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到mp中的最大值进行插入</span></span><br><span class="line">        <span class="type">int</span> max =  <span class="number">-1</span>;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second &gt; max)&#123;</span><br><span class="line">                max = it-&gt;second;<span class="comment">//更新最大值</span></span><br><span class="line">                res.<span class="built_in">clear</span>();</span><br><span class="line">                res.<span class="built_in">insert</span>(it-&gt;first);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(it-&gt;second == max)&#123;</span><br><span class="line">                res.<span class="built_in">insert</span>(it-&gt;first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> *(res.<span class="built_in">begin</span>());</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>简单优化后:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">简单优化后</span></span><br><span class="line"><span class="comment">从数组中找出出现次数最多的偶数（如果这样的数有多个，选取较小的那个）</span></span><br><span class="line"><span class="comment">***/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mostFrequentEven</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//记录偶数出现的次数,存在mp中</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp.<span class="built_in">find</span>(num)==mp.<span class="built_in">end</span>())&#123;<span class="comment">//找不到</span></span><br><span class="line">                    mp[num] = <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    mp[num]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到mp中的最大值进行插入</span></span><br><span class="line">        <span class="type">int</span> max =  <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="keyword">for</span>(unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second &gt; max)&#123;</span><br><span class="line">                max = it-&gt;second;<span class="comment">//更新最大值</span></span><br><span class="line">                res = it-&gt;first;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(it-&gt;second == max &amp;&amp; res &gt; it-&gt;first)&#123;</span><br><span class="line">                 res = it-&gt;first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>每日一题</category>
        <category>2023.4.13</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>【贪心+模拟】 1147. 段式回文</title>
    <url>/2023/04/13/%E3%80%90%E8%B4%AA%E5%BF%83+%E6%A8%A1%E6%8B%9F%E3%80%91%201147.%20%E6%AE%B5%E5%BC%8F%E5%9B%9E%E6%96%87/</url>
    <content><![CDATA[<h2 id="【13】贪心-模拟-1147-段式回文"><a href="#【13】贪心-模拟-1147-段式回文" class="headerlink" title="【13】贪心+模拟 1147. 段式回文"></a>【13】贪心+模拟 1147. 段式回文</h2><p> Problem: <a href="https://leetcode.cn/problems/longest-chunked-palindrome-decomposition/description/">1147. 段式回文</a></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>  拆分字符串，使得拆分的字符串的前部分和后部分完全相同，返回能够拆分出的最大子串数</p>
<p>  贪心：拆分时，能拆就拆&#x3D;&gt;拆分后的字符串尽可能的长&#x3D;&gt;能够拆分出尽可能多的子串</p>
<p> 从小到大递归子串长度，模拟切割</p>
<h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>  递归：<br>     含义：当前字符串，能够拆分出的最大子串数<br>     边界：不能拆&#x3D;&gt;空字符串&#x3D;&gt;长度为0</p>
<p>  字符串的切片[(par1)..(par2)] &#x3D;&gt;[par1,par2) 左闭右开</p>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul>
<li><p>时间复杂度:  O(n^2)</p>
</li>
<li><p>空间复杂度: O(n)</p>
</li>
</ul>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p><code>s.substr(i,b)</code>: <code>i</code>表示从第<code>i</code>个位置开始选取长度为<code>b</code>的子串，<strong>b省略</strong>默认取到字符串末尾</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestDecomposition</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = text.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//递归边界,长度为0不能拆，返回子串数为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n/<span class="number">2</span> ; i++)&#123;<span class="comment">//枚举前后缀长度,从小到大递归前后缀长度可以保证每次分割都是按能拆就拆的思想分割的</span></span><br><span class="line">            <span class="keyword">if</span>(text.<span class="built_in">substr</span>(<span class="number">0</span>,i)==text.<span class="built_in">substr</span>(n-i))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span> + <span class="built_in">longestDecomposition</span>(text.<span class="built_in">substr</span>(i,n<span class="number">-2</span>*i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>每日一题</category>
        <category>2023.4.12</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>LeetCode</tag>
        <tag>算法</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>217.存在重复元素【简单】</title>
    <url>/2023/03/16/217.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91/</url>
    <content><![CDATA[<h1 id="217-存在重复元素【简单】"><a href="#217-存在重复元素【简单】" class="headerlink" title="217.存在重复元素【简单】"></a>217.存在重复元素【简单】</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Problem: <a href="https://leetcode.cn/problems/contains-duplicate/description/">217. 存在重复元素</a></p>
<p>给你一个整数数组 <code>nums</code> 。如果任一值在数组中出现 <strong>至少两次</strong> （appears <strong>at least twice</strong>），返回 <code>true</code> ；如果数组中每个元素互不相同（distinct），返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<h2 id="解题思路与代码"><a href="#解题思路与代码" class="headerlink" title="解题思路与代码"></a>解题思路与代码</h2><p><strong>思路一：</strong></p>
<p>初始化标记为false，数组中任意值如果出现了2次，就可以标记为true</p>
<p>对数值中的每个值出现次数计数，如果某个值在某次计数后出现次数等于2就标记为true。</p>
<p><strong>难点：</strong>不能用count[num]++来计数，因为nums[i]的取值是可以为负数的，但是数组不能有负索引号</p>
<p>**解决办法:**其实我上面的方法也是一种哈希表的方法，但我只用过C里面的map，对js中的map的用法不是很熟练，用map对象可以很好的解决负值的问题。暂时不写，还没理解map的用法。</p>
<p><strong>思路二：</strong></p>
<p>使用一个的新的数组，遍历<code>nums</code>数组，判断新数组<code>n</code>中是否存在<code>nums[i]</code>，若不存在，则将<code>nums[i]</code>插入新数组<code>n</code>；若存在，则返回true；</p>
<p>判断数组中是否有某个值存在的方法为<code>indexOf()</code></p>
<p><strong>思路三：</strong>（官方题解思路）</p>
<p>在对数字从小到大排序之后，数组的重复元素一定出现在相邻位置中。因此，我们可以扫描已排序的数组，每次判断相邻的两个元素是否相等，如果相等则说明存在重复的元素。</p>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul>
<li><p>时间复杂度:<br> $O(n)$</p>
</li>
<li><p>空间复杂度:<br> $O(n)$</p>
</li>
</ul>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>解题思路一：</p>
<p>暂无</p>
<p>解题思路二：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 语言为JavaScript</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> containsDuplicate = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n.<span class="title function_">indexOf</span>(k)==-<span class="number">1</span>)&#123;<span class="comment">//不存在</span></span><br><span class="line">            n.<span class="title function_">push</span>(k);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面for/of循环的遍历是js的写法，是ES6新增的</span></span><br><span class="line">    <span class="comment">//下面的代码的for循环遍历方式是c中的惯用写法，是常规的for循环</span></span><br><span class="line">    <span class="comment">// for(let i = 0; i &lt; nums.length; i++)&#123;//遍历数组</span></span><br><span class="line">    <span class="comment">//     if(n.indexOf(nums[i])==-1)&#123;//不存在</span></span><br><span class="line">    <span class="comment">//         n.push(nums[i]);</span></span><br><span class="line">    <span class="comment">//     &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//         return true;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>学习计划</category>
        <category>数据结构</category>
        <category>数组</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《JavaScript权威指南》读书笔记</title>
    <url>/2023/03/16/%E3%80%8AjavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="《javaScript权威指南》读书笔记"><a href="#《javaScript权威指南》读书笔记" class="headerlink" title="《javaScript权威指南》读书笔记"></a>《javaScript权威指南》读书笔记</h1><p>本书笔记基于David Flanagan的《javaScript权威指南》原书第七版中文译本，也就是犀牛书。</p>
<h2 id="词法结构"><a href="#词法结构" class="headerlink" title="词法结构"></a>词法结构</h2><h3 id="JavaScript程序的文本"><a href="#JavaScript程序的文本" class="headerlink" title="JavaScript程序的文本"></a>JavaScript程序的文本</h3><ul>
<li>区分大小写</li>
<li>忽略<strong>程序记号（token）</strong>之间的空格，很大程度上忽略换行符（也有例外）</li>
</ul>
<blockquote>
<p>不太理解什么叫程序记号</p>
</blockquote>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*单行注释*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *多行注释</span></span><br><span class="line"><span class="comment"> *每行开头额外的*不是必需的，只是为了美观</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>直接出现在程序中的数据值，如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="number">1.2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="标识符与保留字"><a href="#标识符与保留字" class="headerlink" title="标识符与保留字"></a>标识符与保留字</h3><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>用于命名常量、变量、属性、函数和类，就是一个名字，必需由<strong>字母，下划线，美元符号</strong>开头，可由<strong>字母、下划线、美元符号、数字</strong>组成。</p>
<h4 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h4><p>一些不能作为标识符使用的单词，如for、if和while</p>
<p>当然还有一些比较复杂的情况，在一定情况下可以使用为标识符。不过最简单的做法就是不要使用这些单词作为标识符。</p>
<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>JavaScript程序由Unicode字符集编写，意味标识符可以使用Unicode字母、数字和象形文字（不支持表情符号）。</p>
<h4 id="Unicode转义序列"><a href="#Unicode转义序列" class="headerlink" title="Unicode转义序列"></a>Unicode转义序列</h4><p>由于某些计算机硬件和软件无法识别、处理Unicode字符，故定义了转义字符，以<code>\u</code>开头，后跟4为十六进制数或包含在一对花括号内的1~6位十六进制数字。</p>
<blockquote>
<p>花括号版本是ES6新增的</p>
</blockquote>
<p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20230316020145144.png" alt="image-20230316020145144"></p>
<h4 id="Unicode归一化"><a href="#Unicode归一化" class="headerlink" title="Unicode归一化"></a>Unicode归一化</h4><p>由于不同编码方式的Unicode字符在js中是区分的，如下面的两个标识符</p>
<p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20230316021128685.png" alt="image-20230316021128685"></p>
<p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20230316021145803.png" alt="image-20230316021145803"></p>
<p>虽然看起来完全相同，但由于它们的二进制编码是不同的，所以js也会认为它们是不同的，这会导致看起来相同的两个标识符其实表示的是两个不同的标识符，在赋值等各个操作中会出现问题。</p>
<p>故在执行程序前，需要保证编辑器能够对源代码执行Unicode归一化。</p>
<h3 id="可选的分号"><a href="#可选的分号" class="headerlink" title="可选的分号"></a>可选的分号</h3><p>分号用于分隔语句。</p>
<p>分号可省略的情况：</p>
<ul>
<li><p>两条语句分别写在两行（不是一定的）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = <span class="number">3</span>;<span class="comment">//此时这个分号可以省略</span></span><br><span class="line">b = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">a = <span class="number">3</span>;b = <span class="number">4</span>;<span class="comment">//分号是必须的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也不是所有的换行符都会被当作为分号,只有在不添加符号就无法解析代码的情况下才会把换行符当作分号</span></span><br><span class="line"><span class="keyword">let</span> a</span><br><span class="line">a </span><br><span class="line">= </span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="comment">//会被解释为</span></span><br><span class="line"><span class="keyword">let</span> a; a = <span class="number">3</span>; <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这种机制会引发一些问题,如下面的例子</span></span><br><span class="line"><span class="keyword">let</span> y = x + f</span><br><span class="line">(a+b).<span class="title function_">toString</span>()</span><br><span class="line"><span class="comment">//会被解释为</span></span><br><span class="line"><span class="keyword">let</span> y = x + <span class="title function_">f</span>(a+b).<span class="title function_">toString</span>();<span class="comment">//不一定与作者的真实意图一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另外一种情况，return、throw、yield、break、continue后面的换行符是一定会被解释为分号的</span></span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line"><span class="literal">true</span>;</span><br><span class="line"><span class="comment">//一定会被解释为</span></span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line"><span class="literal">true</span>;</span><br><span class="line"><span class="comment">//故一定不能在这些保留字和他们后面的表达式之间加换行符</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外，涉及到++、–操作符，必须与操作的表达式位于同一行。</p>
<p>箭头函数中的<code>=&gt;</code>也必须与参数列表在同一行</p>
</blockquote>
</li>
<li><p>在程序的末尾，接下来的加号是<code>&#125;</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora的查找（替换）快捷键</title>
    <url>/2023/03/14/Typora%E7%9A%84%E6%9F%A5%E6%89%BE%EF%BC%88%E6%9B%BF%E6%8D%A2%EF%BC%89%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h3 id="Typora的查找（替换）快捷键"><a href="#Typora的查找（替换）快捷键" class="headerlink" title="Typora的查找（替换）快捷键"></a>Typora的查找（替换）快捷键</h3><ul>
<li><p>查找：Ctrl+F</p>
<p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20230314102135161.png" alt="image-20230314102135161"></p>
</li>
<li><p>替换：Ctrl+H</p>
</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20230314102239226.png" alt="image-20230314102239226"></p>
]]></content>
      <tags>
        <tag>Typora</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础语法-dom-bom-js-es6新语法-jQuery-数据可视化</title>
    <url>/2023/03/12/JavaScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-dom-bom-js-es6%E6%96%B0%E8%AF%AD%E6%B3%95-jQuery-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<h1 id="JavaScript基础语法-dom-bom-js-es6新语法-jQuery-数据可视化"><a href="#JavaScript基础语法-dom-bom-js-es6新语法-jQuery-数据可视化" class="headerlink" title="JavaScript基础语法-dom-bom-js-es6新语法-jQuery-数据可视化"></a>JavaScript基础语法-dom-bom-js-es6新语法-jQuery-数据可视化</h1><p>该课程笔记基于b站pink老师的课程视频，视频链接：<a href="https://www.bilibili.com/video/BV1Sy4y1C7ha/?spm_id_from=333.337.search-card.all.click&vd_source=47b8ae38c6099b5bc1a761ca77b05155">https://www.bilibili.com/video/BV1Sy4y1C7ha/?spm_id_from=333.337.search-card.all.click&amp;vd_source=47b8ae38c6099b5bc1a761ca77b05155</a></p>
<h2 id="JS基础语法"><a href="#JS基础语法" class="headerlink" title="JS基础语法"></a>JS基础语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li>单行注释 快捷键<code>ctrl + /</code></li>
<li>多行注释快捷键<code>shift + alt + a</code></li>
<li>vscode中修改多行注释的快捷键<code>ctrl + shift + /</code></li>
</ul>
<h3 id="输入输出语句"><a href="#输入输出语句" class="headerlink" title="输入输出语句"></a>输入输出语句</h3><p>输出：</p>
<ul>
<li>浏览器弹出警示框：<code>alert(msg)</code></li>
<li>浏览器控制台打印输出信息：<code>console.log(msg)</code></li>
<li>浏览器弹出输入框，用户可以输入：<code>prompt(msg)</code></li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>变量声明与使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//age 为一个变量</span></span><br><span class="line"><span class="keyword">var</span> age;</span><br><span class="line"><span class="comment">//变量赋值</span></span><br><span class="line">age = <span class="number">18</span>;</span><br><span class="line"><span class="comment">//变量初始化</span></span><br><span class="line"><span class="keyword">var</span> myname = <span class="string">&#x27;小明&#x27;</span>;<span class="comment">//JS中用单引号，css和html中用双引号</span></span><br><span class="line"><span class="comment">//输出变量值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myname);</span><br><span class="line"><span class="comment">//多个变量一起申明</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>,</span><br><span class="line">    address = <span class="string">&#x27;sss&#x27;</span>,</span><br><span class="line">    gz = <span class="number">1323</span>;</span><br><span class="line"><span class="comment">//变量只声明但是不赋值，输出为undefined</span></span><br><span class="line"><span class="comment">//不声明直接赋值使用是可以的，但是会变成全局变量，不推荐</span></span><br><span class="line"><span class="comment">//不声明不赋值，使用时会直接报错</span></span><br></pre></td></tr></table></figure>

<p><strong>变量的命名规范</strong></p>
<ul>
<li>严格区分大小写</li>
<li>不能以数字开头</li>
<li>由字母，下划线，数字，美元符号组成。</li>
<li>不能使用关键字和保留字<code>var for是错误写法</code></li>
<li>变量名必须有意义</li>
<li>遵循驼峰命名法：首字母小写，后面单词的首字母大写，例<code>myFirstName</code></li>
<li>不用使用<code>name</code>作为变量名</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>JS是<strong>弱类型语言</strong>，变量数据类型是只有程序在运行过程中，根据等号右边的值确定的。</p>
<p>JS是<strong>动态语言</strong>，变量的数据类型是可以<strong>变化的</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="string">&#x27;Pink&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h4><ul>
<li><p>数字型：<code>Number</code>，包括整数和小数</p>
<ul>
<li>数字前面加<code>0</code> 表示八进制 010 &#x3D; 8(10进制)</li>
<li>数字面前加<code>0x</code> 表示十六进制 0xa &#x3D; 10(10进制)</li>
<li>数字的最大值：<code>Number.MAX_VALUE;//1.79e+308</code></li>
<li>数字的最小值：<code>Number.MIN_VALUE;//5E-324</code></li>
<li>无穷大：<code>Infinity</code></li>
<li>无穷小：<code>-Infinity</code></li>
<li>非数值：<code>NaN</code><ul>
<li><code>isNaN()</code>这个方法用来判断一个变量是否是非数字，如果是数字返回的是<code>false</code>，反之返回<code>true</code></li>
</ul>
</li>
</ul>
</li>
<li><p>字符串型：加单（双）引号的内容，JS中推荐<strong>单引号</strong>。外双内单，外单内双</p>
<ul>
<li>字符串转义符：都是用<code>\</code>开头，写在字符串内部<ul>
<li>换行符<code>\n</code></li>
<li>斜杆<code>\\</code></li>
<li>单引号<code>\&#39;</code></li>
<li>双引号<code>\&quot;</code></li>
<li>tab缩进<code>\t</code></li>
<li>空格<code>\b</code></li>
</ul>
</li>
<li>获取字符串的长度：<code>str.length</code></li>
<li>字符串拼接：<code>字符串+任意类型 = 拼接之后的字符串</code></li>
</ul>
</li>
<li><p>布尔型：<code>true</code>&amp;<code>false</code></p>
</li>
<li><p>未定义数据类型：<code>undefined</code></p>
<p>未定义+数字 &#x3D; NaN</p>
</li>
<li><p>空值：<code>null</code></p>
<p>空值 + 数字&#x3D; 数字</p>
</li>
</ul>
<h4 id="获取数据类型"><a href="#获取数据类型" class="headerlink" title="获取数据类型"></a>获取数据类型</h4><p><code>typeof age</code>： 检测数据类型</p>
<h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><ol>
<li><p>转换为字符串</p>
<ul>
<li><p>num.toString()</p>
</li>
<li><p>String(num)</p>
</li>
<li><p>num+’’()空字符</p>
</li>
</ul>
</li>
<li><p>转换为数字型</p>
<ul>
<li><code>parseInt(str)</code>只能取整数部分</li>
<li><code>parseFloat(str)</code>可以读取到小数部分</li>
<li><code>Number(str)</code>强制转换</li>
<li>隐式转换:<code>&#39;12&#39;-0  ----&gt; 12</code>，<code>&#39;123&#39;-&#39;120&#39; = 3</code>，<code>&#39;123&#39;*1---&gt;123</code></li>
</ul>
</li>
<li><p>转换为布尔型：<code>Boolean(var)</code></p>
</li>
</ol>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><p><code>+,-,*,/,%</code></p>
<p>浮点数不能直接进行运算，会有精度问题</p>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20220814160547782.png" alt="image-20220814160547782"></p>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20220814160653602.png" alt="image-20220814160653602"></p>
<p>逻辑中断逻辑与</p>
<p><code>表达式1 &amp;&amp; 表达式2</code>：表达式1为真返回表达式2，表达式1为假返回表达式1</p>
<p>逻辑中断逻辑或</p>
<p><code>表达式1 &amp;&amp; 表达式2</code>：表达式1为真返回表达式1，表达式1为假返回表达式2</p>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20220814161715893.png" alt="image-20220814161715893"></p>
<h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20220814205126091.png" alt="image-20220814205126091"></p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>顺序流程控制</p>
<p>分支流程控制</p>
<h4 id="分支流程控制"><a href="#分支流程控制" class="headerlink" title="分支流程控制"></a>分支流程控制</h4><ul>
<li><p>if-else语句</p>
</li>
<li><p>switch语句</p>
</li>
<li><p>三元表达式：条件表达式 ？ 表达式1 ：表达式2</p>
<blockquote>
<p>条件表达式成立返回表达式1，反之返回2</p>
</blockquote>
</li>
</ul>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>for</p>
<p>while</p>
<p>do-while</p>
<p>continue关键字：立刻跳出当前循环，进入下一次循环</p>
<p>break关键字：退出整个循环</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>创建数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br></pre></td></tr></table></figure>

<p>遍历数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增数组元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>新增数组元素，改变数组长度</span><br><span class="line">arr.<span class="property">length</span> = <span class="number">5</span>;<span class="comment">//手动增加数组长度</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>修改索引号</span><br><span class="line">arr[arr.<span class="property">length</span>] = <span class="string">&#x27;shiff&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>冒泡排序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">23</span>, <span class="number">43</span>, <span class="number">52</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">45</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= arr.<span class="property">length</span> - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">let</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>声明函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHI</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">num1, num2</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span></span><br><span class="line"><span class="keyword">var</span> 变量名 = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getSum = <span class="keyword">function</span>(<span class="params">num1, num2</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>js函数申明中的形参可以不用申明变量类型</p>
</blockquote>
<p>调用函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">sayHI</span>();</span><br></pre></td></tr></table></figure>

<p><code>arguments</code>:函数中的伪参数，伪数组，拥有length属性，拥有索引号,不具有数组中的某些方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>全局作用域：整个script标签，或者一个单独的js文件</p>
<p>局部作用域：函数作用域（函数内部），局部作用域内：局部覆盖全局</p>
<p>作用域链：就近原则</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">        consolo.<span class="title function_">log</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();<span class="comment">//---&gt; num = 11;接近原则</span></span><br></pre></td></tr></table></figure>

<h3 id="JS的预解析"><a href="#JS的预解析" class="headerlink" title="JS的预解析"></a>JS的预解析</h3><p>js引擎先预解析，在代码执行：</p>
<p>（1）预解析：js引擎会把js里面所有var 还有function提升到当前作用域的最前面</p>
<p>（2）代码执行：按照代码书写顺序从上往下执行</p>
<p>2.预解析 包括：</p>
<ul>
<li>变量预解析：把所有变量的声明提升到当前作用域的最前面，但是不提升赋值</li>
<li>函数预解析：</li>
</ul>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象是一个具体的事物</p>
<p>对象的构成：</p>
<ul>
<li>属性：特征</li>
<li>方法：行为</li>
</ul>
<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>利用字面量创建对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;<span class="comment">//创建了一个空的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    uname : <span class="string">&#x27;shiff&#x27;</span>,</span><br><span class="line">    age : <span class="number">18</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;女&#x27;</span>,</span><br><span class="line">    <span class="attr">sayHi</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi~&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象里面的属性或者方法我们采取键值对的形式 键 属性名 ： 值 属性值</span></span><br><span class="line"><span class="comment">//多个属性或者方法之间用逗号，最后一个属性或方法不用加逗号</span></span><br><span class="line"><span class="comment">//方法冒号后面跟的是一个匿名函数</span></span><br><span class="line"><span class="comment">//第二种调用方法：对象名[‘属性名’]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[<span class="string">&#x27;gender&#x27;</span>]);</span><br><span class="line"><span class="comment">//调用对象的方法：对象名.方法（）</span></span><br><span class="line">obj.<span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure>

<p>利用new Object创建对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用new Object创建对象</span></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//创建了一个空对象</span></span><br><span class="line">obj1.<span class="property">uname</span> = <span class="string">&#x27;shiff&#x27;</span>;</span><br><span class="line">obj1.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">obj1.<span class="property">gender</span> = <span class="string">&#x27;女&#x27;</span>;</span><br><span class="line">obj1.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">uname</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1[<span class="string">&#x27;uname&#x27;</span>]);</span><br><span class="line">obj1.<span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure>

<p>利用<strong>构造函数</strong>创建对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> 构造函数名()&#123;</span><br><span class="line">    <span class="variable language_">this</span>.属性 = 值；</span><br><span class="line">    <span class="variable language_">this</span>.方法 = <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> 构造函数名();</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用构造函数创造对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Star</span>(<span class="params">uname, age, gender</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = uname;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">gender</span> = gender;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sing</span> = <span class="keyword">function</span>(<span class="params">song</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(song)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ldh = <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;刘德华&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;男&#x27;</span>);<span class="comment">//调用函数返回的是一个对象</span></span><br><span class="line"><span class="comment">//1.构造函数名字首字母要大写</span></span><br><span class="line"><span class="comment">//2.构造函数不需要return 就可以返回对象</span></span><br><span class="line"><span class="comment">//3.调用构造函数，必须要使用new</span></span><br><span class="line"><span class="comment">//4.属性和方法面前必须添加this</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ldh.<span class="property">name</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ldh[<span class="string">&#x27;gender&#x27;</span>])</span><br><span class="line">ldh.<span class="title function_">sing</span>(<span class="string">&#x27;冰雨&#x27;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>构造函数，是抽象了对象的公共部分，封装到了函数里面</p>
<p>通过<code>new</code>关键字创建对象的过程称为对象实例化</p>
</blockquote>
<h4 id="new关键字执行过程"><a href="#new关键字执行过程" class="headerlink" title="new关键字执行过程"></a><strong>new关键字执行过程</strong></h4><ol>
<li>new构造函数在内存中创建一个空的对象</li>
<li>this就会指向刚才创建的空对象</li>
<li>执行构造函数里面的代码，给这个空对象添加属性和方法</li>
<li>返回这个对象</li>
</ol>
<h4 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a><strong>遍历对象</strong></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name : <span class="string">&#x27;shiff&#x27;</span>,</span><br><span class="line">    age : <span class="number">18</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;女&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;233&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for(变量in对象)&#123;&#125;</span></span><br><span class="line"><span class="comment">//也可以遍历方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> obj)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(k);<span class="comment">//k变量输出 得到的是属性名</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj[k]);<span class="comment">//obj[k]得到的是属性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JS的内置对象"><a href="#JS的内置对象" class="headerlink" title="JS的内置对象"></a>JS的内置对象</h3><p>JS中的对象类型：</p>
<ul>
<li>自定义对象</li>
<li>内置对象</li>
<li>浏览器对象</li>
</ul>
<h4 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h4><p>常用方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="property">PI</span>					<span class="comment">//圆周率</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">floor</span>()			<span class="comment">//向下取整</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">ceil</span>()				<span class="comment">//向上取整</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">round</span>()			<span class="comment">//四舍五入 就近取整</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">abs</span>()				<span class="comment">//绝对值</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>()/<span class="title class_">Math</span>.<span class="title function_">min</span>()	<span class="comment">//最大/最小值</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">random</span>()			<span class="comment">//随机数</span></span><br></pre></td></tr></table></figure>

<h4 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h4><p>Date()日期对象是一个构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个对象</span></span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">//如果没有参数，返回系统的当前时间</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">valueof</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getTime</span>());</span><br><span class="line"><span class="title function_">valueof</span>()</span><br><span class="line"><span class="title function_">getTime</span>()</span><br><span class="line"><span class="comment">//返回我们现在时间距离1970.1.1总的毫秒数(时间戳)</span></span><br><span class="line"><span class="comment">//也可以</span></span><br><span class="line">date1 =  +<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date1);</span><br><span class="line"><span class="comment">//h5新增</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>());<span class="comment">//不需要创建实例</span></span><br></pre></td></tr></table></figure>

<p>倒计时：将来的时间戳-现在时间戳</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">repairZero</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; <span class="number">10</span> ? a : <span class="string">&#x27;0&#x27;</span> + a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">countDown</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> nowTime = +<span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">//返回的是当前时间总的毫秒数</span></span><br><span class="line">    <span class="keyword">let</span> inputTime = +<span class="keyword">new</span> <span class="title class_">Date</span>(time);<span class="comment">//返回的是用户输入时间总的毫秒数</span></span><br><span class="line">    <span class="keyword">let</span> times = (inputTime - nowTime) / <span class="number">1000</span>; <span class="comment">//除以1000得到秒数</span></span><br><span class="line">    <span class="keyword">let</span> d = <span class="built_in">parseInt</span>(times/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>);<span class="comment">//天</span></span><br><span class="line">    d = <span class="title function_">repairZero</span>(d);</span><br><span class="line">    <span class="keyword">let</span> h = <span class="built_in">parseInt</span>(times/<span class="number">60</span>/<span class="number">60</span>%<span class="number">24</span>);<span class="comment">//时</span></span><br><span class="line">    h = <span class="title function_">repairZero</span>(h);</span><br><span class="line">    <span class="keyword">let</span> m = <span class="built_in">parseInt</span>(times/<span class="number">60</span>%<span class="number">60</span>);<span class="comment">//分</span></span><br><span class="line">    m = <span class="title function_">repairZero</span>(m);</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">parseInt</span>(times%<span class="number">60</span>);<span class="comment">//当前的秒</span></span><br><span class="line">    s = <span class="title function_">repairZero</span>(s);</span><br><span class="line">    <span class="keyword">return</span> d + <span class="string">&#x27;天&#x27;</span> + h + <span class="string">&#x27;时&#x27;</span> + m + <span class="string">&#x27;分&#x27;</span> + s +<span class="string">&#x27;秒&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">countDown</span>(<span class="string">&quot;2022-8-17 15:11:00&quot;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h4><p>创建数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>字面量</span><br><span class="line"><span class="keyword">let</span> arr = [];<span class="comment">//空数组</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>构造函数</span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">2</span>);<span class="comment">//创建数组长度为2的空数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//等价于[2,3]有两个数组元素</span></span><br></pre></td></tr></table></figure>

<p>检测是否为数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">instanceof</span> 运算符</span><br><span class="line"></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>;<span class="comment">//值为true或false判断arr是否为数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span><span class="title class_">Array</span>.<span class="title function_">isArray</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(<span class="string">&#x27;shiff&#x27;</span>);<span class="comment">//false</span></span><br><span class="line"><span class="comment">//返回true或者false，H5新增，ie9以上版本支持</span></span><br></pre></td></tr></table></figure>

<p>添加删除数组的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.push()在数组末尾添加一个或多个元素</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">4</span>);<span class="comment">//arr = [1,2,3,4]</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">5</span>,<span class="string">&#x27;pink&#x27;</span>);<span class="comment">//arr = [1,2,3,4,5,&#x27;pink&#x27;]</span></span><br><span class="line"><span class="comment">//push的返回值是新数组的长度，原素组也会发生变化</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">push</span>(<span class="number">6</span>));<span class="comment">//7</span></span><br><span class="line"><span class="comment">//2.unshift在数组前面添加一个或多个元素，基本特性与push想同</span></span><br><span class="line">arr.<span class="title function_">unshift</span>(<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;green&#x27;</span>);</span><br><span class="line"><span class="comment">//3.pop()删除数组中的最后一个元素</span></span><br><span class="line">arr.<span class="title function_">pop</span>();</span><br><span class="line"><span class="comment">//返回是的删除的那个元素，原数组会发生变化</span></span><br><span class="line"><span class="comment">//4.shift()删除数组的第一个元素</span></span><br><span class="line"><span class="comment">//返回的是删除的那个元素，原数组会发生变化</span></span><br><span class="line">arr.<span class="title function_">shift</span>();</span><br></pre></td></tr></table></figure>

<p>翻转数组：<code>arr.reverse()</code></p>
<p>冒泡排序：<code>arr.sort()</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;<span class="comment">//升序</span></span><br><span class="line">    <span class="comment">//return b - a;//降序</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure>

<p>数组索引方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>,<span class="string">&#x27;pink&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>]；</span><br><span class="line"><span class="keyword">let</span> a = arr.<span class="title function_">indexOf</span>(<span class="string">&#x27;blue&#x27;</span>);<span class="comment">// a = 1;</span></span><br><span class="line"><span class="comment">//indexOf返回第一个满足条件bule的索引号</span></span><br><span class="line"><span class="comment">//如果找不到该元素，返回-1</span></span><br><span class="line"><span class="comment">//lastindexOf从后面往前查找第一个为blue的索引号</span></span><br><span class="line"><span class="keyword">let</span> b = arr.<span class="title function_">lastindexOf</span>(<span class="string">&#x27;blue&#x27;</span>);<span class="comment">//b = 3</span></span><br></pre></td></tr></table></figure>

<p>数组转换为字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="title function_">toString</span>()将我们的数组转换为字符串</span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> string = a.<span class="title function_">toString</span>();<span class="comment">//1,2,3</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span><span class="title function_">join</span>(分隔符)</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> s = b.<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>);<span class="comment">//1-2-3</span></span><br><span class="line"><span class="keyword">let</span> s = b.<span class="title function_">join</span>(<span class="string">&#x27;&amp;&#x27;</span>);<span class="comment">//1&amp;2&amp;3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>concat()</code>:连接两个或多个数组，返回值为一个新的数组</li>
<li><code>slice()</code>:数组截取<code>slice(begin,end)</code>，返回被截取的新数组</li>
<li><code>splice()</code>:数组删除<code>splice(第几个开始，要删除几个数)</code>,返回被删除的新数组，且会影响到原数组</li>
</ul>
<h3 id="基本包装类型-字符串"><a href="#基本包装类型-字符串" class="headerlink" title="基本包装类型:字符串"></a>基本包装类型:字符串</h3><p>把简单数据类型包装为了复杂数据类型</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20220817152010722.png" alt="image-20220817152010722"></p>
<p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20220817153317139.png" alt="image-20220817153317139"></p>
<p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20220817153821881.png" alt="image-20220817153821881"></p>
<p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20220817154139984.png" alt="image-20220817154139984"></p>
<h2 id="Web-APIs：DOM-BOM"><a href="#Web-APIs：DOM-BOM" class="headerlink" title="Web APIs：DOM+BOM"></a>Web APIs：DOM+BOM</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>应用程序编程接口，是一些预定义函数</p>
<p><strong>Web API</strong>是浏览器提供的浏览器功能和页面元素的AIP</p>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>处理HTML和XML的接口</p>
<p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20220817185243063.png" alt="image-20220817185243063"></p>
<ul>
<li>文档：一个页面</li>
<li>元素：所有标签</li>
<li>节点：所有内容（标签、属性、文本、注释）</li>
</ul>
<h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><ul>
<li><p>通过ID获取：getElementById()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;time&quot;</span>&gt;<span class="number">2019</span>-<span class="number">9</span>-<span class="number">9</span>&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">//1.getElementById()通过获取元素id获得元素对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">let</span> timer = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;time&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">console</span>.<span class="title function_">log</span>(timer);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> timer);<span class="comment">//返回的是对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">console</span>.<span class="title function_">dir</span>(timer);<span class="comment">//dir查看对象的属性和方法</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>


</li>
<li><p>通过标签获取：getElementsByTagName()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>你是大好人<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>你是大好人<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>你是大好人<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>你是大好人<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>你是大好人<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//返回的是 获取过来的元素对象的集合 以伪数组的形式存储</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> lis = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;li&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(lis);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(lis[<span class="number">0</span>]);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//用for遍历</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; lis.<span class="property">length</span>; i++) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(lis[<span class="number">0</span>]);<span class="comment">//得到的元素是动态的</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">//如果页面中只有一个li，返回的还是伪数组的形式</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">//如果界面中没有元素，会返回一个空的伪数组</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">获取ul标签下的li标签</span><br><span class="line">element.<span class="title function_">getElementsByTagName</span>(),获取的时候不包括父元素自己</span><br><span class="line"><span class="comment">//获取文档中的所有ul,注意：伪数组不能作为父元素，一定要指明是哪一个</span></span><br><span class="line"><span class="keyword">let</span> ul = <span class="variable language_">document</span>.<span class="title function_">getElementByTagName</span>(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> li = ul[<span class="number">0</span>].<span class="title function_">getElementByTagName</span>(<span class="string">&#x27;li&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过类名获取元素：document.getElementsByClassName(‘类名’)</p>
</li>
<li><p>通过**querySelector()**获取元素，返回的是第一个元素对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过类名获取元素，返回一个伪数组</span></span><br><span class="line"><span class="keyword">let</span> boxes = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;box&#x27;</span>);</span><br><span class="line"><span class="comment">//querySelctor返回指定选择器的第一个元素对象</span></span><br><span class="line"><span class="comment">//通过类名.类名</span></span><br><span class="line"><span class="keyword">let</span> firstbox = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>);</span><br><span class="line"><span class="comment">//通过id #id名</span></span><br><span class="line"><span class="keyword">let</span> nav = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#nav&#x27;</span>);</span><br><span class="line"><span class="comment">//通过标签名</span></span><br><span class="line"><span class="keyword">let</span> li = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;li&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取body元素：<code>document.body</code></p>
</li>
<li><p>获取html元素：<code>document.documentElement</code></p>
</li>
</ul>
<h4 id="事件基础"><a href="#事件基础" class="headerlink" title="事件基础"></a>事件基础</h4><p>事件：监控行为——————触发响应</p>
<p>事件三要素：事件源、事件类型、事件处理程序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button id = <span class="string">&quot;btn&quot;</span>&gt;唐伯虎&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//点击一个按钮，弹出对话框</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//事件有三部分组成：事件源、事件类型、事件处理程序</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//事件源：事件被触发的对象  按钮</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//事件类型： 如何触发 比如鼠标点击</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//事件处理程序 通过一个函数赋值的方式完成</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">alert</span>(<span class="string">&#x27;点秋香&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>执行步骤三要素：</p>
<ol>
<li>获取事件源</li>
<li>注册事件（绑定事件）</li>
<li>添加事件处理程序（采用函数赋值形式）</li>
</ol>
<p>常见的鼠标事件</p>
<p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20220818003550188.png" alt="image-20220818003550188"></p>
<h4 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h4><p>利用DOM操作元素来改变元素里面的内容、属性</p>
<p><strong>改变元素内容</strong></p>
<ul>
<li><p><strong>element.innerText</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//当我们点击了按钮，div里面的文字会发生变化</span></span><br><span class="line">    <span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        div.<span class="property">innerText</span> = <span class="title function_">getDate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getDate</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">//获得一个时间对象，里面不写内容就是当前时间，动态的</span></span><br><span class="line">        <span class="keyword">let</span> year = date.<span class="title function_">getFullYear</span>();</span><br><span class="line">        <span class="keyword">let</span> month = date.<span class="title function_">getMonth</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> dates = date.<span class="title function_">getDate</span>();</span><br><span class="line">        <span class="keyword">let</span> arr = [<span class="string">&#x27;星期日&#x27;</span>, <span class="string">&#x27;星期一&#x27;</span>, <span class="string">&#x27;星期二&#x27;</span>, <span class="string">&#x27;星期三&#x27;</span>, <span class="string">&#x27;星期四&#x27;</span>, <span class="string">&#x27;星期五&#x27;</span>, <span class="string">&#x27;星期六&#x27;</span>];</span><br><span class="line">        <span class="keyword">let</span> day = date.<span class="title function_">getDay</span>();<span class="comment">//获得星期几</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;今天是：&#x27;</span> + year + <span class="string">&#x27;年&#x27;</span> + month + <span class="string">&#x27;月&#x27;</span> + dates + <span class="string">&#x27;日&#x27;</span> + arr[day];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们元素可以不用添加时间</span></span><br><span class="line">    <span class="keyword">let</span> p = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">    p.<span class="property">innerText</span> = <span class="title function_">getDate</span>();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>elemen.innerHTML</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//innerText和innerHTML的区别</span></span><br><span class="line">    <span class="comment">//1.innerText 不识别html标签 非标准 去除空格和换行</span></span><br><span class="line">    <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    div.<span class="property">innerText</span> = <span class="string">&#x27;&lt;strong&gt;今天是：2022&lt;strong&gt;&#x27;</span></span><br><span class="line">    <span class="comment">//1.innerText 识别html标签 W3C标准</span></span><br><span class="line">    div.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;strong&gt;今天是：2022&lt;strong&gt;&#x27;</span></span><br><span class="line">    <span class="comment">//这两个属性是可读写的 可以获取元素里面的内容 保留空格和换行</span></span><br><span class="line">    p = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">innerText</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">innerHTML</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>常见元素的属性操作</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//修改元素属性 scr</span></span><br><span class="line">    <span class="comment">//1.获取元素</span></span><br><span class="line">    <span class="keyword">let</span> pic1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> pic2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> img = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">    <span class="comment">//2.注册事件</span></span><br><span class="line">    pic2.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        img.<span class="property">src</span> = <span class="string">&#x27;images/暂无考勤记录.png&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pic1.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        img.<span class="property">src</span> = <span class="string">&#x27;images/暂无回放.png&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>表单元素的操作属性</strong></p>
<p>常见表单属性：</p>
<ul>
<li>type</li>
<li>value</li>
<li>checked</li>
<li>selected</li>
<li>disabled</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//1.获取元素</span></span><br><span class="line">    <span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line">    <span class="comment">//2.注册事件 处理程序</span></span><br><span class="line">    btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// input.innerHTML = &#x27;点击了&#x27;; 这个是普通盒子，比如div标签里面的内容</span></span><br><span class="line">        <span class="comment">//表单里面的值 文字内容是通过value来修改的</span></span><br><span class="line">        input.<span class="property">value</span> = <span class="string">&#x27;被点击了&#x27;</span>;</span><br><span class="line">        <span class="comment">//如果想要某个表单被禁用 不能再点击 disabled</span></span><br><span class="line">        <span class="comment">//btn.disabled = true;//禁用该表单</span></span><br><span class="line">        <span class="comment">//也可以</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">disabled</span> = <span class="literal">true</span>;<span class="comment">//this指向的是时间函数的调用这，即btn</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>样式属性操作</strong></p>
<ul>
<li><p><code>element.style</code>:行内样式操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;#fff&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&#x27;25px&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>element.className</code>：类名样式操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div &gt;</span><br><span class="line">    文本</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> test = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    test.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//点击后让div获取类名</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//让当前元素的类名改为change&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">className</span> = <span class="string">&#x27;change&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//可以通过修改元素的classname更改元素的样式，适合于样式较多或者功能较复杂的情况</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//如果想要保留原先的类名，使用多类名选择器</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">this</span>.<span class="property">className</span> = <span class="string">&#x27;first change&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20221023182746829.png" alt="image-20221023182746829"></p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20221024225404480.png" alt="image-20221024225404480"></p>
<h4 id="排他算法"><a href="#排他算法" class="headerlink" title="排他算法"></a>排他算法</h4><p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20221024232758635.png" alt="image-20221024232758635"><br>先排除其他人，在设置自己的样式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//1.获取所有按钮元素</span></span><br><span class="line">    <span class="keyword">const</span> bts = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">    <span class="comment">//btns得到的是伪数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bts.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        bts[i].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">            <span class="comment">//1.我们先把所有的按钮背景颜色去掉</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; bts.<span class="property">length</span>; i++)&#123;</span><br><span class="line">                bts[i].<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.然后再让当前的颜色变为pink色</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>课程笔记</category>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库报错Incorrect-string-value</title>
    <url>/2023/03/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%A5%E9%94%99Incorrect-string-value/</url>
    <content><![CDATA[<h3 id="数据库报错Incorrect-string-value-‘-xE7-x94-xB7‘-for-column-‘name‘-at-row-1"><a href="#数据库报错Incorrect-string-value-‘-xE7-x94-xB7‘-for-column-‘name‘-at-row-1" class="headerlink" title="数据库报错Incorrect string value: ‘\xE7\x94\xB7‘ for column ‘name‘ at row 1"></a>数据库报错Incorrect string value: ‘\xE7\x94\xB7‘ for column ‘name‘ at row 1</h3><p><img src="C:\Users\12726\AppData\Roaming\Typora\typora-user-images\image-20230312024828536.png" alt="image-20230312024828536"></p>
<p>报错内容为在name列插入的第一条数据的字符串值是不正确的，主要原因是我插入的数据为汉字，为中文字符串，需要使用到utf-8字符集，而默认是使用的是latin1字符集。</p>
<p>解决方案：用这个命令更改表名，去覆盖它的原有字符集，就可以实现成功插入中文</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE interface_info（这里改成自己的表名） CONVERT TO CHARACTER SET utf8;</span><br></pre></td></tr></table></figure>

<p>参考博文：<a href="https://blog.csdn.net/weixin_63639665/article/details/128206602">https://blog.csdn.net/weixin_63639665/article/details/128206602</a></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>踩坑</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>idea的全局搜索（替换）快捷键</title>
    <url>/2023/03/12/idea%E7%9A%84%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2%EF%BC%88%E6%9B%BF%E6%8D%A2%EF%BC%89%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h2 id="idea的全局搜索（替换）快捷键"><a href="#idea的全局搜索（替换）快捷键" class="headerlink" title="idea的全局搜索（替换）快捷键"></a>idea的全局搜索（替换）快捷键</h2><p>可以鼠标选中想要搜索的内容在按快捷键或者按完快捷键后输入想要搜索的内容</p>
<ul>
<li>ctrl+F 搜索范围为当前文件，不可替换</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20230311230431152.png" alt="image"></p>
<ul>
<li>ctrl+R 搜索范围为当前文件，可替换</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20230312034130905.png" alt="image-20230312034130905"></p>
<ul>
<li>ctrl+shift+R 搜索范围为整个项目，可替换</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20230311230702057.png" alt="image-20230311230702057"></p>
]]></content>
      <tags>
        <tag>快捷键</tag>
        <tag>踩坑</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>站点记录</title>
    <url>/2023/03/12/%E7%AB%99%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="站点记录"><a href="#站点记录" class="headerlink" title="站点记录"></a>站点记录</h2><h3 id="工具类站点"><a href="#工具类站点" class="headerlink" title="工具类站点"></a>工具类站点</h3><p>1.时间戳转换： <a href="https://tool.lu/timestamp">https://tool.lu/timestamp</a><br>2.b站视频下载： <a href="https://www.urlgot.cn/">https://www.urlgot.cn/</a></p>
<h3 id="学习类站点"><a href="#学习类站点" class="headerlink" title="学习类站点"></a>学习类站点</h3><h4 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h4><ul>
<li><a href="https://developers.aliwork.com/docs/guide/start">钉钉宜搭.开发者中心</a></li>
<li>前端框架：<a href="https://pro.ant.design/zh-CN/docs/getting-started">ant.design.pro</a></li>
<li>博客框架：<a href="https://hexo.io/zh-cn/docs">hexo文档</a></li>
</ul>
<h3 id="仓库类站点"><a href="#仓库类站点" class="headerlink" title="仓库类站点"></a>仓库类站点</h3>]]></content>
      <tags>
        <tag>站点链接</tag>
      </tags>
  </entry>
  <entry>
    <title>利用idea和maven仓库下载依赖</title>
    <url>/2023/03/11/%E5%88%A9%E7%94%A8idea%E5%92%8Cmaven%E4%BB%93%E5%BA%93%E4%B8%8B%E8%BD%BD%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<h2 id="利用idea和maven仓库下载依赖"><a href="#利用idea和maven仓库下载依赖" class="headerlink" title="利用idea和maven仓库下载依赖"></a>利用idea和maven仓库下载依赖</h2><p>以添加<a href="https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-boot-starter">MyBatis Plus</a>依赖为例</p>
<p>背景：用spring boot 初始化一个项目后，发现MyBatis Plus依赖没有添加</p>
<p><strong>1.在maven仓库搜索mybaits-plus</strong></p>
<p>仓库地址：<a href="https://mvnrepository.com(不同浏览器访问速度不一样,我用的火狐浏览器,感觉比用谷歌访问快很多,如果无法访问,可以换浏览器试试)/">https://mvnrepository.com（不同浏览器访问速度不一样，我用的火狐浏览器，感觉比用谷歌访问快很多，如果无法访问，可以换浏览器试试）</a></p>
<p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20230311053841423.png" alt="image-20230311053841423"></p>
<p>点击选中使用最多的包</p>
<p><strong>2.版本可以自行选择，尽量选择使用人数比较多的那个版本</strong></p>
<p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20230311053955492.png" alt="image-20230311053955492"></p>
<p><strong>3.如果使用maven管理的包，直接复制框中的代码</strong></p>
<p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20230311054228774.png" alt="image-20230311054228774"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>4.将复制的代码黏贴到pom.xml文件的依赖标签<code>&lt;dependencies&gt;</code>下，同时点击右上角的M图标进行更新</strong></p>
<p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20230311054522516.png" alt="image-20230311054522516"></p>
<p>右上角没有图标的话，可以右边栏（或者在左边）的Maven标签打开配置栏</p>
<p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20230311054738541.png" alt="image-20230311054738541"></p>
<p>点击刷新按钮进行更新下载依赖</p>
<p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20230311054938693.png" alt="image-20230311054938693"></p>
]]></content>
      <tags>
        <tag>idea</tag>
        <tag>maven</tag>
        <tag>依赖管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>github-clone克隆报错</title>
    <url>/2023/03/11/github-clone%E5%85%8B%E9%9A%86%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20230307110603157.png" alt="image-20230307110603157"></p>
<p>报错两次</p>
<p><strong>1. OpenSSL SSL_read: Connection was reset, errno 10054</strong></p>
<p>这是服务器的SSL证书没有经过第三方机构的签署，所以报错。错误原因可能是网络不稳定，连接超时造成的。重试clone</p>
<p><strong>2.The requested URL returned error: 408</strong></p>
<p>408很可能是请求超时，大概率还是网络问题，再次重试</p>
<p>经过两次重试后成功！</p>
]]></content>
      <tags>
        <tag>踩坑</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>无效的目标发行版17</title>
    <url>/2023/03/11/%E6%97%A0%E6%95%88%E7%9A%84%E7%9B%AE%E6%A0%87%E5%8F%91%E8%A1%8C%E7%89%8817/</url>
    <content><![CDATA[<p><img src="https://cdn.staticaly.com/gh/SHIFFF/Blogcdn@master/img/image-20230310153146114.png" alt="image-20230310153146114"></p>
<p>出现无效的源发行版 就是jdk版本环境不一致造成的</p>
<p>在spring Initializr上下载的spring boot 版本默认是3.0.4</p>
<p>但是 springboot3.0 需要jdk17支持，如果没有安装jdk17 只需把springboot版本降低即可</p>
<p>我用的jdk版本是1.8，所以需要降低springboot版本</p>
]]></content>
      <tags>
        <tag>踩坑</tag>
        <tag>idea</tag>
        <tag>springboot</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
</search>
